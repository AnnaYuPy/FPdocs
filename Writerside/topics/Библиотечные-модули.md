# Библиотечные модули

**Подсистема SCADA**
## <a name="_heading=h.lnxbz9"></a>**Модуль system\_utils (v1)**
Модуль с набором вспомогательных функций, предназначенных для поиска и обработки системных объектов. Применяется для оптимизации работы с объектами в системе.

**Общая информация**

Модуль system\_utils предоставляет функции для управления объектами системы и обработки данных. Код написан на языке программирования Erlang. Если функция выбрасывает исключение или происходит сбой, транзакция будет отменена. При успешном выполнении функции возвращают атом ok. Для логирования рекомендуется использовать макросы:

- ?LOGINFO( "my info text: ~p", [Info] )
- ?LOGWARNING( "my warning text: ~p", [Warning] )
- ?LOGERROR( "my error text: ~p", [Error] )

|**Функция**|**Описание**|
| :-: | :-: |
|find\_by\_pattern/2|<p>: Ищет объекты в хранилище данных, соответствующие заданному шаблону.</p><p>**Параметры**:</p><p>- Root (binary): Корневой путь проекта.</p><p>- Pattern (binary): Шаблон для поиска.</p><p>&emsp;**Возвращает**: Список путей к объектам.</p><p>&emsp;**Пример использования**:</p><p>&emsp;system\_utils:find\_by\_pattern(<<"KAZ/UZHNIY">>, <<"/root/FP/prototypes/telemetry/fields">>).</p><p>&emsp;</p>|
|csv\_to\_archive/2|<p>: Загружает данные из CSV-файла и сохраняет их в архив.</p><p>**Параметры**:</p><p>- Archive (binary): Архив для сохранения данных.</p><p>- CSVFile (binary): Путь к CSV-файлу.</p><p>&emsp;**Возвращает**: Атом ok в случае успеха или {error, Reason} в случае ошибки.</p><p>&emsp;**Пример использования**:</p><p>&emsp;system\_utils:csv\_to\_archive(<<"my\_archive">>, <<"/path/to/file.csv">>).</p>|
|vclass\_from\_object/1|<p>: Определяет класс объекта по его пути.</p><p>**Параметры**:</p><p>- Object (binary): Объект, для которого необходимо определить класс.</p><p>&emsp;**Возвращает**: Целое число, представляющее класс объекта, или 0, если совпадение не найдено.</p><p>&emsp;**Пример использования**:</p><p>&emsp;system\_utils:vclass\_from\_object(Object).</p><p>&emsp;</p>|
|utc\_time/0|<p>: Возвращает текущие дату и время в формате UTC.</p><p>**Параметры**: Нет.</p><p>**Возвращает**: Строку с отформатированной датой и временем.</p><p>**Пример использования**:</p><p>system\_utils:utc\_time().</p><p></p>|
|create\_csv/2|<p>: Создает CSV-файл с данными, извлеченными из хранилища данных.</p><p>**Параметры**:</p><p>- Path (binary): Путь для выборки данных.</p><p>- File (binary): Имя файла для сохранения.</p><p>&emsp;**Возвращает**: Атом ok в случае успеха.</p><p>&emsp;**Пример использования**:</p><p>&emsp;system\_utils:create\_csv(<<"/data/path">>, <<"output.csv">>).</p>|
|delete\_elements/4|<p>: Удаляет элементы из хранилища данных, соответствующие заданным критериям.</p><p>**Параметры**:</p><p>- Root (binary): Корневой путь проекта.</p><p>- Folder (binary): Папка для выборки.</p><p>- Pattern (binary): Шаблон для поиска.</p><p>- Name (binary): Имя элемента для удаления.</p><p>&emsp;**Возвращает**: Атом ok в случае успеха.</p><p>&emsp;**Пример использования**:</p><p>&emsp;system\_utils:delete\_elements(<<"UZHNIY">>, <<"@models">>, <<"/root/FP/prototypes/telemetry/fields">>, <<"Uac">>).</p><p>&emsp;</p>|
|set\_state\_value/4|<p>: Устанавливает значение полей объектов state, вложенных в объекты, соответствующие заданным прототипам и находящиеся в заданном контексте.</p><p>**Параметры**:</p><p>- Context (binary): Контекст, в котором будет установлено значение.</p><p>- EdgePrototypes (list): Список прототипов.</p><p>- Path (binary): Относительный путь к объекту состояния</p><p>- FieldMap (map): Карта полей для обновления.</p><p>&emsp;**Возвращает**: Атом ok в случае успеха.</p><p>&emsp;**Пример использования**:</p><p>&emsp;system\_utils:set\_state\_value(<<"/root/FP/PROJECT/KAZ/UZHNIY/Kyzylorda">>, [<<"isolator">>, <<"earth\_isolator">>], <<"/state">>, #{<<"in\_value">> => 1}).</p><p>&emsp;</p>|

## <a name="_heading=h.35nkun2"></a>**Модуль weather\_service**
Служба интеграции прогноза погоды. Этот модуль взаимодействует с внешним API для получения данных о погоде, которые могут использоваться для анализа и прогноза производительности системы, учитывая метеоусловия.

**Общая информация**

Модуль weather\_service предназначен для получения информации о текущей погоде и прогноза на 24 часа. Модуль разработан на языке Erlang. Для логирования сообщений предлагается использовать макросы: ?LOGINFO, ?LOGWARNING, ?LOGERROR и обеспечивать откат транзакций при ошибках. При успешном оформлении возвращается атом ok.

|**Функция**|**Описание**|
| :-: | :-: |
|forecast24/1|<p>: Получает прогноз погоды на 24 часа через API OpenWeatherMap.</p><p>**Параметры**:</p><p>- Obj (map): Объект, содержащий координаты (широта lat и долгота lon).</p><p>&emsp;**Возвращает**: Обработанные данные о прогнозе, включая массивы температуры, давления, влажности, скорости и направления ветра.</p><p>&emsp;**Пример использования**:</p><p>&emsp;weather\_service:forecast24(Object).</p><p>&emsp;**Детали реализации**:</p><p>- Чтение координат из объекта с использованием fp\_db:read\_fields.</p><p>- Формирование URL для запроса к API.</p><p>- Выполнение HTTP-запроса с использованием модуля httpc.</p><p>- Парсинг ответа JSON с помощью библиотеки jsx.</p><p>- Обработка данных прогноза для температуры, давления, влажности, скорости и направления ветра.</p>|
|current/1|<p>: Получает текущую погоду через API OpenWeatherMap.</p><p>**Параметры**:</p><p>- Obj (map): Объект, содержащий координаты (широта lat и долгота lon).</p><p>&emsp;**Возвращает**: Карта значений с текущими погодными данными:</p><p>- ts: Временная метка.</p><p>- pressure: Давление (гПа).</p><p>- temperature: Температура (°C).</p><p>- humidity: Влажность (%).</p><p>- wind\_speed: Скорость ветра (м/с).</p><p>- wind\_direction: Направление ветра (градусы).</p><p>&emsp;**Пример использования**:</p><p>&emsp;weather\_service:current(Object).</p><p>&emsp;**Детали реализации**:</p><p>- Чтение координат из объекта с использованием fp\_db:read\_fields.</p><p>- Формирование URL для запроса к API.</p><p>- Выполнение HTTP-запроса с использованием модуля httpc.</p><p>- Парсинг ответа JSON с помощью библиотеки jsx.</p><p>- Извлечение значений давления, температуры, влажности, скорости и направления ветра.</p><p>&emsp;</p>|

**Примечания**

- Убедитесь, что у вас есть действительный ключ API OpenWeatherMap.
- Для повышения производительности рекомендуется кешировать результаты запросов.

## <a name="_heading=h.1ksv4uv"></a>**Модуль fp\_userlib\_archive**
Модуль для работы с архивами. Предназначен для управления архивированием данных и взаимодействия с базой архивов, включая создание, удаление и обновление записей.

**Общая информация**

Модуль fp\_userlib\_archive предоставляет функцию для сохранения данных из CSV-файла в архив. Код написан на языке программирования Erlang. При возникновении ошибок транзакция будет отменена. Рекомендуется логировать информацию о процессе выполнения с использованием макросов:

- ?LOGINFO
- ?LOGWARNING
- ?LOGERROR

|**Функция**|**Описание**|
| :-: | :-: |
|csv\_to\_archive/1|<p>: Сохраняет данные из CSV-файла, переданного в виде строки в формате Base64, в архив.</p><p>**Параметры**:</p><p>- Args (map): Словарь с ключами:</p><p>- archive\_path (binary): Путь к архиву, куда будут записаны данные.</p><p>- content (binary): Содержимое CSV-файла в формате Base64.</p><p>&emsp;**Возвращает**: Атом ok в случае успешного выполнения или выбрасывает исключение в случае ошибки.</p><p>&emsp;**Пример использования**:</p><p>&emsp;Args = #{</p><p>&emsp;`  `<<"archive\_path">> => <<"/path/to/archive">>,</p><p>&emsp;`  `<<"content">> => <<"VGltZXN0YW1wLFZhbHVlCjE2NzMwMjUwMDAsMTIzLjQ1Cg==">> %% Base64-encoded CSV</p><p>&emsp;}.</p><p>&emsp;fp\_userlib\_archive:csv\_to\_archive(Args).</p><p>&emsp;**Детали реализации**:</p><p>- Декодирует содержимое CSV-файла из Base64 в бинарный формат.</p><p>- Разделяет данные на строки и колонки.</p><p>- Конвертирует данные времени (timestamp) и значений (value) в подходящие типы.</p><p>- Пытается записать обработанные данные в указанный архив с помощью функции fp\_archive:insert\_values.</p><p>- В случае ошибки записывает информацию в лог.</p><p>&emsp;</p>|

**Примечания**

- Данные CSV-файла должны быть корректно закодированы в Base64.
- Архив, указанный в archive\_path, должен существовать и быть доступным для записи.
- В случае возникновения исключений данные не будут записаны.

## <a name="_heading=h.44sinio"></a>**Модуль fp\_pf\_utils**
Вспомогательные функции для интеграции с PowerFactory (PF). Этот модуль помогает в управлении и мониторинге сетевых моделей, позволяя обмениваться данными между SCADA-системой и PF.

**Общая информация**

Модуль fp\_pf\_utils предоставляет функции для взаимодействия с PowerFactory Service. Основные функции включают операции для получения данных, выполнения расчётов и запуска динамических сценариев. Код написан на языке программирования Erlang. Все транзакции откатываются в случае ошибок, а успешное выполнение возвращает атом ok.

Рекомендуется использовать следующие макросы для логирования:

- ?LOGINFO
- ?LOGWARNING
- ?LOGERROR

|**Функция**|**Описание**|
| :-: | :-: |
|pf\_get/0|<p>: Получает данные из PowerFactory на основе заданных параметров проекта.</p><p>**Параметры**: Нет.</p><p>**Возвращает**: Результат выполнения запроса к PowerFactory Service.</p><p>**Пример использования**:</p><p>fp\_pf\_utils:pf\_get().</p><p>**Детали реализации**:</p><p>- Формирует параметры проекта, включая имя сетки, имя проекта, имя сценария и тип сессии.</p><p>- Выполняет запрос через fp\_powerfactory\_service:pf\_service\_update с использованием хоста и порта.</p>|
|pf\_execute/0|<p>: Выполняет расчёт на основе заданных параметров проекта и указания идентификатора LDF.</p><p>**Параметры**: Нет.</p><p>**Возвращает**: Результат выполнения запроса к PowerFactory Service.</p><p>**Пример использования**:</p><p>fp\_pf\_utils:pf\_execute().</p><p>**Детали реализации**:</p><p>- Формирует параметры проекта, включая имя сетки, имя проекта, имя сценария и тип сессии.</p><p>- Определяет идентификатор объекта ComLdfOID для выполнения расчёта.</p><p>- Выполняет запрос через fp\_powerfactory\_service:pf\_service\_update с использованием хоста и порта.</p><p>&emsp;</p>|
|pf\_dynamics/0|<p>: Запускает динамический сценарий расчёта на основе заданных параметров проекта.</p><p>**Параметры**: Нет.</p><p>**Возвращает**: Результат выполнения запроса к PowerFactory Service.</p><p>**Пример использования**:</p><p>fp\_pf\_utils:pf\_dynamics().</p><p>**Детали реализации**:</p><p>- Формирует параметры проекта, включая имя сетки, имя проекта, имя сценария и тип сессии.</p><p>- Выполняет запрос через fp\_powerfactory\_service:pf\_service\_update с использованием хоста и порта.</p>|

**Примечания**

- Хост и порт для запросов определены через макросы ?HOST и ?PORT.
- Перед использованием функций убедитесь, что PowerFactory Service доступен по указанным параметрам.

## <a name="_heading=h.2jxsxqh"></a>**Модуль bms\_service**
Логика сервиса для системы рынка баланса. Этот модуль управляет обменом данными с балансирующим рынком, обрабатывая данные о спросе и предложении.

**Общая информация**

Модуль bms\_service предоставляет функции для интеграции с REST API и обработки данных из внешних систем. Код написан на языке Erlang. Все методы модуля работают с объектами, позволяют редактировать их и обеспечивают откат транзакций в случае ошибок. Логирование рекомендуется выполнять с использованием макросов ?LOGINFO, ?LOGWARNING и ?LOGERROR.

|**Функция**|**Описание**|
| :-: | :-: |
|find\_objects/1|<p>: Ищет объекты в хранилище данных на основе переданных фильтров.</p><p>**Параметры**:</p><p>- Filter (map): Словарь, содержащий ключи:</p><p>- <<".path">>: Корневой путь объекта.</p><p>- <<".name">>: Имя объекта.</p><p>- <<".prototype">>: Прототип объекта.</p><p>&emsp;**Возвращает**: Список объектов, соответствующих заданным фильтрам, либо {error, [[], []]} в случае ошибки.</p><p>&emsp;**Пример использования**:</p><p>&emsp;Filter = #{</p><p>&emsp;`  `<<".path">> => <<"/root/PROJECT/">>,</p><p>&emsp;`  `<<".name">> => <<"subject">>,</p><p>&emsp;`  `<<".prototype">> => <<"/root/FP/prototypes/subject/fields">></p><p>&emsp;}.</p><p>&emsp;bms\_service:find\_objects(Filter).</p><p>&emsp;</p>|
|run/0|<p>: Основная функция для выполнения задачи. Осуществляет получение объектов, авторизацию через REST API, запрос данных и запись их в архивы.</p><p>**Параметры**: Нет.</p><p>**Возвращает**: Атом ok при успешном выполнении, либо описание ошибки.</p><p>**Пример использования**:</p><p>bms\_service:run().</p><p>**Детали реализации**:</p><p>- Формирует фильтры для поиска объектов.</p><p>- Выполняет запрос для получения токена авторизации через REST API.</p><p>- Осуществляет запрос данных по объектам с использованием токена.</p><p>- Преобразует полученные данные и записывает их в архивы.</p><p>&emsp;</p>|
|write\_to\_db/2|<p>: Записывает данные в хранилище данных, удаляя старые записи в указанном диапазоне.</p><p>**Параметры**:</p><p>- Data (list): Список данных для записи.</p><p>- Archive (binary): Путь к архиву.</p><p>&emsp;**Возвращает**: {ok, written\_to\_db} при успешной записи либо {error, {write\_failure, Reason}} при ошибке.</p><p>&emsp;**Пример использования**:</p><p>&emsp;bms\_service:write\_to\_db(Data, Archive).</p><p>&emsp;</p>|
|extract\_data/2|<p>: Извлекает и преобразует данные из ответа API для последующей обработки.</p><p>**Параметры**:</p><p>- Objects (list): Список объектов для обработки.</p><p>- Response (map): Ответ от REST API.</p><p>&emsp;**Возвращает**: Преобразованные данные или ok, если дата не соответствует требованиям.</p><p>&emsp;**Пример использования**:</p><p>&emsp;bms\_service:extract\_data(Objects, Response).</p>|

**Примечания**

- Функции transform\_purchases/2 и transform\_sales/2 используются для преобразования данных покупок и продаж в формате {Timestamp, Value}.
- Убедитесь, что REST API доступен и корректно настроен для выполнения запросов.
- Все временные метки преобразуются в миллисекунды для использования в архивах.
- При работе с датами используются вспомогательные функции is\_today/1 и is\_tomorrow/1 для определения актуальности данных.

## <a name="_heading=h.z337ya"></a>**Модуль calculation (v2)**
Модуль для выполнения различных вычислений. Поддерживает более сложные операции, включая обработку данных в режиме реального времени.

**Общая информация**

Модуль calculation предоставляет функцию для вычисления значений на основе строки, содержащей арифметические операции, такие как сложение и вычитание. Код написан на языке Erlang и включает обработку ошибок и логирование. Основная цель — обработка строк с числами и получение вычисленного результата.

|**Функция**|**Описание**|
| :-: | :-: |
|evaluate/2|<p>: Выполняет вычисление на основе переданной строки с арифметическими операциями.</p><p>**Параметры**:</p><p>- Name (binary): Имя объекта, которое используется для получения дополнительных значений.</p><p>- String (binary): Строка с числами и арифметическими операциями (+ и -).</p><p>&emsp;**Возвращает**: Вычисленное числовое значение или {error, Reason} в случае ошибки.</p><p>&emsp;**Пример использования**:</p><p>&emsp;calculation:evaluate(<<"example">>, <<"10+20-5">>).</p><p>&emsp;**Детали реализации**:</p><p>- Проверяет, является ли String бинарной строкой.</p><p>- Разбивает строку на токены с помощью функции tokenize/1.</p><p>- Передаёт токены в функцию evaluate\_tokens/2 для выполнения вычислений.</p><p>- Логирует ошибки, если они возникают.</p>|
|tokenize/1|<p>: Разбивает строку на токены по операторам + и -.</p><p>**Параметры**:</p><p>- String (binary): Входная строка.</p><p>&emsp;**Возвращает**: Список токенов в виде бинарных строк.</p><p>&emsp;**Пример использования**:</p><p>&emsp;calculation:tokenize(<<"10+20-5">>).</p><p>&emsp;</p>|
|evaluate\_tokens/2|<p>: Выполняет вычисление на основе списка токенов.</p><p>**Параметры**:</p><p>- Name (binary): Имя объекта.</p><p>- Tokens (list): Список токенов (числа, операторы + и -).</p><p>&emsp;**Возвращает**: Результат вычисления.</p><p>&emsp;**Пример использования**:</p><p>&emsp;calculation:evaluate\_tokens(<<"example">>, [<<"10">>, <<"+">>, <<"20">>, <<"-">>, <<"5">>]).</p><p>&emsp;</p>|
|get\_value/1|<p>: Получает значение поля out\_value из объекта в хранилище данных.</p><p>**Параметры**:</p><p>Token (binary): Путь к объекту в виде строки.</p><p>**Возвращает**: Значение поля out\_value или вызывает исключение в случае ошибки.</p><p>**Пример использования**:</p><p>calculation:get\_value(<<"/root/FP/PROJECT/example">>).</p><p></p>|
|get\_catalog/2|<p>: Получает значение из каталога формул и вычисляет его, если оно содержит арифметическое выражение.</p><p>**Параметры**:</p><p>- Name (binary): Имя объекта.</p><p>- Token (binary): Идентификатор формулы.</p><p>&emsp;**Возвращает**: Числовое значение или результат вычисления.</p><p>&emsp;**Пример использования**:</p><p>&emsp;calculation:get\_catalog(<<"example">>, <<"formula\_1">>).</p><p>&emsp;</p>|
|split\_path/1|<p>: Разделяет путь на папку и имя объекта.</p><p>**Параметры**:</p><p>- Bin (binary): Полный путь к объекту.</p><p>&emsp;**Возвращает**: Кортеж {Folder, Name}.</p><p>&emsp;**Пример использования**:</p><p>&emsp;calculation:split\_path(<<"/root/FP/PROJECT/example">>).</p><p>&emsp;</p>|
|strings\_to\_binaries/1|<p>: Преобразует список строк в список бинарных строк.</p><p>**Параметры**:</p><p>- Strings (list): Список строк.</p><p>&emsp;**Возвращает**: Список бинарных строк.</p><p>&emsp;**Пример использования**:</p><p>&emsp;calculation:strings\_to\_binaries(["10", "+", "20", "-", "5"]).</p>|
|token\_is\_docker/1|<p>: Проверяет, является ли токен идентификатором объекта в системе Docker.</p><p>**Параметры**:</p><p>- Token (binary): Токен для проверки.</p><p>&emsp;**Возвращает**: true или false.</p><p>&emsp;**Пример использования**:</p><p>&emsp;calculation:token\_is\_docker(<<"/docker/object">>).</p>|
|token\_type/1|<p>: Определяет тип токена (целое число, число с плавающей точкой или неизвестный тип).</p><p>**Параметры**:</p><p>- Token (binary): Токен для анализа.</p><p>&emsp;**Возвращает**: int, float или false.</p><p>&emsp;**Пример использования**:</p><p>&emsp;calculation:token\_type(<<"10.5">>).</p><p>&emsp;</p>|

**Примечания**

- Убедитесь, что входная строка корректно сформирована и содержит только поддерживаемые операторы и числа.
- В случае ошибок вызовите логирование для диагностики причин.
- Функции работают с бинарными строками, поэтому при вводе данных убедитесь, что строки находятся в правильном формате.

## <a name="_heading=h.3j2qqm3"></a>**Модуль docker\_client (v0.1)**
Клиент для взаимодействия с Docker. Используется для управления контейнерами Docker из среды Faceplate Studio, что удобно для разворачивания и мониторинга приложений в контейнерах.

**Общая информация**

Модуль docker\_client предоставляет интерфейс для взаимодействия с Docker Engine через API. Функции модуля позволяют получать список контейнеров, создавать и запускать контейнеры. Код написан на языке Erlang.

|**Функция**|**Описание**|
| :-: | :-: |
|list\_containers/0|<p>: Возвращает список контейнеров, запущенных в Docker Engine.</p><p>**Параметры**: Нет.</p><p>**Возвращает**:</p><p>- {ok, Containers}: Список контейнеров в формате JSON.</p><p>- {error, {unexpected\_status, StatusCode}}: Неожиданный HTTP-код ответа.</p><p>- {error, Reason}: Причина ошибки при выполнении запроса.</p><p>&emsp;**Пример использования**:</p><p>&emsp;docker\_client:list\_containers().</p><p>&emsp;**Детали реализации**:</p><p>- Формирует URL для запроса /containers/json.</p><p>- Выполняет HTTP GET-запрос.</p><p>- Декодирует ответ JSON или возвращает ошибку при некорректном статусе.</p>|
|create\_container/1|<p>: Создаёт новый контейнер на основе указанного образа.</p><p>**Параметры**:</p><p>- Image (binary): Имя образа Docker.</p><p>&emsp;**Возвращает**:</p><p>- {ok, ContainerInfo}: Информация о созданном контейнере.</p><p>- {error, {unexpected\_status, StatusCode}}: Неожиданный HTTP-код ответа.</p><p>- {error, Reason}: Причина ошибки при выполнении запроса.</p><p>&emsp;**Пример использования**:</p><p>&emsp;docker\_client:create\_container(<<"nginx">>).</p><p>&emsp;**Детали реализации**:</p><p>- Формирует URL для запроса /containers/create.</p><p>- Кодирует тело запроса в формате JSON, включая имя образа и команду.</p><p>- Выполняет HTTP POST-запрос.</p><p>- Декодирует ответ JSON или возвращает ошибку при некорректном статусе.</p>|
|start\_container/1|<p>: Запускает контейнер с указанным идентификатором.</p><p>**Параметры**:</p><p>- ContainerId (binary): Идентификатор контейнера.</p><p>&emsp;**Возвращает**:</p><p>- {ok, <<"Container started successfully">>}: Контейнер успешно запущен.</p><p>- {error, {unexpected\_status, StatusCode}}: Неожиданный HTTP-код ответа.</p><p>- {error, Reason}: Причина ошибки при выполнении запроса.</p><p>&emsp;**Пример использования**:</p><p>&emsp;docker\_client:start\_container(<<"e90e34656806">>).</p><p>&emsp;**Детали реализации**:</p><p>- Формирует URL для запроса /containers/{ContainerId}/start.</p><p>- Выполняет HTTP POST-запрос.</p><p>- Возвращает сообщение об успешном запуске или ошибку при некорректном статусе.</p>|

**Конфигурация**

**Базовый URL**: Определён через макрос ?DOCKER\_URL и по умолчанию равен http://localhost:2375.

**Примечания**

- Для работы функций требуется, чтобы Docker API был доступен по указанному адресу.
- Функции используют библиотеку HTTP клиента httpc и JSON-парсер jsx.
- В случае ошибок рекомендуется использовать логирование с помощью макросов ?LOGINFO, ?LOGWARNING, ?LOGERROR.

## <a name="_heading=h.1y810tw"></a>**Модуль fp\_powerfactory\_service**
Модуль для интеграции с PowerFactory (PF).

**Общая информация**

Модуль fp\_powerfactory\_service предназначен для интеграции SCADA-системы Faceplate с расчетным ПО PowerFactory. Он обеспечивает обмен данными между этими системами посредством формирования, отправки и обработки JSON-запросов через промежуточный сервер server.py.

|**Функция**|**Описание**|
| :-: | :-: |
|pf\_service\_update(Params, [OID], Host, Port)|<p>**Параметры:**</p><p>Params: Должен содержать структуру следующего вида:</p><p>#{ </p><p>`     	`<<"study\_case\_name">> =></p><p><<"Study Case">>,</p><p>`    `<<"session\_type">></p><p>=> <<"calculation">>,</p><p>`    `<<"project\_name">></p><p>=> <<".MODEL\_SCADA\_V1107\_\_\_DEMO(1)">>,</p><p>`    `<<"operation\_scenario\_name">></p><p>=> <<"dyn">>,</p><p>`    `<<"id">> => 1,</p><p>`    `<<"grid\_name">></p><p>=> "Grid",</p><p>`    `<<"func\_name">></p><p>=> "get"</p><p>},</p><p>где "func\_name" должно содержать имя функции, которая используется для формирования json, поле "id" должно содержать идентификатор текущего экземпляра faceplate, остальные поля должны содержать параметры проекта PowerFactory, который будет использоваться для расчетов.</p><p>[OID]: Может содержать либо пустой erlang лист, либо OID передаваемого объекта.</p><p>Host и Port: адрес и порт сервера, на котором должен быть запущен server.py.</p><p>**Возвращает**: Json-результат выполнения запроса.</p><p>**Пример использования:**</p><p>fp\_powerfactory\_service:pf\_service\_update(Params, [], "127.0.0.1", 8080).</p><p>**Детали реализации**:</p><p>Данная функция не создает новые объекты в хранилище данных Faceplate, если объекты в принятом от PowerFactory json не найдены в базе данных Faceplate.</p>|
|pf\_service\_create\_update(Params, [OID], Host, Port)|<p>: Создает новые объекты в хранилище данных Faceplate, если объекты в принятом от PowerFactory json не найдены в хранилище данных Faceplate. </p><p>**Параметры:**</p><p>Params: Должен содержать структуру следующего вида:</p><p>#{ </p><p>`     	`<<"study\_case\_name">> =></p><p><<"Study Case">>,</p><p>`    `<<"session\_type">></p><p>=> <<"calculation">>,</p><p>`    `<<"project\_name">></p><p>=> <<".MODEL\_SCADA\_V1107\_\_\_DEMO(1)">>,</p><p>`    `<<"operation\_scenario\_name">></p><p>=> <<"dyn">>,</p><p>`    `<<"id">> => 1,</p><p>`    `<<"grid\_name">></p><p>=> "Grid",</p><p>`    `<<"func\_name">></p><p>=> "get"</p><p>},</p><p>где "func\_name" должно содержать имя функции, которая используется для формирования json, поле "id" должно содержать идентификатор текущего экземпляра faceplate, остальные поля должны содержать параметры проекта PowerFactory, который будет использоваться для расчетов.</p><p>[OID]: Может содержать либо пустой erlang лист, либо OID передаваемого объекта.</p><p>Host и Port: адрес и порт сервера, на котором должен быть запущен server.py.</p><p>**Возвращает**: Json-результат выполнения запроса.</p><p>**Пример использования:**</p><p>fp\_powerfactory\_service:pf\_service\_create\_update(Params, [], "127.0.0.1", 8080).</p><p>**Детали реализации**:</p><p>Может использоваться для создания объектов в каталогах (например, для загрузки библиотеки базовых типов из PowerFactory).</p>|
|pf\_service\_get\_section(ts, funct)|<p>: предназначена для формирования так называемого "среза" данных. Срез данных представляет собой json, сформированный по принципам, описанным в п.6.1.</p><p>Отличия заключается в том, что данные для формирования json извлекаются не из полей объектов Faceplate, а из соответствующих этим полям архивов.</p><p>**Параметры:**</p><p>ts: Определяет момент времени, для которого нужно получить данные.</p><p>funct: Содержит название функции, которая используется для формирования json (см. п 6.1).</p><p>**Возвращает:**<br>Json-объект с данными за указанный момент времени.</p><p>**Пример использования:**</p><p>fp\_powerfactory\_service:pf\_service\_get\_section(1669387200, "get\_section").</p><p>**Детали реализации:**</p><p>Принципы формирования Json соответствуют описанию в п. 6.1, с той разницей, что данные извлекаются не из полей объектов Faceplate, а из архивов.</p>|

**Общая информация**

Модуль fp\_powerfactory\_service предоставляет API для интеграции с PowerFactory. Его функциональность включает управление каталогами оборудования, вызов функций PowerFactory и обработку связанных данных. Код написан на языке Erlang и включает механизмы логирования и обработки ошибок.

|**Функция**|**Описание**|
| :-: | :-: |
|on\_init/0|<p>: Инициализирует модуль, добавляя JSON-API для взаимодействия с PowerFactory.</p><p>**Параметры**: Нет.</p><p>**Возвращает**: Атом ok при успешной инициализации.</p><p>**Пример использования**:</p><p>fp\_powerfactory\_service\_old:on\_init().</p>|
|power\_factory\_import\_equipment\_library/1|<p>: Импортирует библиотеку оборудования в PowerFactory.</p><p>**Параметры**:</p><p>- {CatalogName, PFProjectParamsPath}: Кортеж, содержащий имя каталога и путь к параметрам проекта PowerFactory.</p><p>&emsp;**Возвращает**: Результат выполнения функции.</p><p>&emsp;**Пример использования**:</p><p>&emsp;fp\_powerfactory\_service\_old:power\_factory\_import\_equipment\_library({<<"CatalogName">>, <<"/path/to/project/params">>}).</p>|
|get\_equipment\_library\_catalog/1|<p>: Возвращает идентификаторы содержимого и полей каталога оборудования.</p><p>**Параметры**:</p><p>- CatalogName (binary): Имя каталога.</p><p>&emsp;**Возвращает**:</p><p>- {ContentOID, FieldsOID}: Кортеж с идентификаторами содержимого и полей каталога.</p><p>- Выбрасывает исключение, если каталог не найден.</p><p>&emsp;**Пример использования**:</p><p>&emsp;fp\_powerfactory\_service\_old:get\_equipment\_library\_catalog(<<"CatalogName">>).</p>|
|power\_factory\_call\_function/1|<p>: Выполняет вызов функции PowerFactory.</p><p>**Параметры**:</p><p>- {Context, PFProjectParamsPath, FunctionName}: Кортеж, содержащий контекст, путь к параметрам проекта и имя функции.</p><p>&emsp;**Возвращает**: Результат вызова функции в формате HTTP-ответа.</p><p>&emsp;**Пример использования**:</p><p>&emsp;fp\_powerfactory\_service\_old:power\_factory\_call\_function({Context, <<"/path/to/params">>, <<"function\_name">>}).</p>|
|power\_factory\_call\_function\_old/1|<p>: Устаревший метод вызова функции PowerFactory с дополнительным логированием.</p><p>**Параметры**:</p><p>- {Context, PFProjectParamsPath, FunctionName}: Кортеж, содержащий контекст, путь к параметрам проекта и имя функции.</p><p>&emsp;**Возвращает**: Результат вызова функции в формате HTTP-ответа.</p><p>&emsp;**Пример использования**:</p><p>&emsp;fp\_powerfactory\_service\_old:power\_factory\_call\_function\_old({Context, <<"/path/to/params">>, <<"function\_name">>}).</p>|
|get\_pf\_project\_params/1|<p>: Возвращает параметры проекта PowerFactory.</p><p>**Параметры**:</p><p>- PFProjectParamsPath (binary): Путь к параметрам проекта.</p><p>&emsp;**Возвращает**: Словарь с параметрами проекта.</p><p>&emsp;**Пример использования**:</p><p>&emsp;fp\_powerfactory\_service\_old:get\_pf\_project\_params(<<"/path/to/project/params">>).</p>|
|load\_config/0|<p>: Загружает конфигурацию модуля из файла.</p><p>**Параметры**: Нет.</p><p>**Возвращает**: Словарь с конфигурацией.</p><p>**Пример использования**:</p><p>Config = fp\_powerfactory\_service\_old:load\_config().</p><p></p>|
|get\_json/4|<p>: Формирует JSON-объект для передачи в PowerFactory.</p><p>**Параметры**:</p><p>- Config (map): Конфигурация.</p><p>- OIDsByElement (map): Сопоставление элементов и их идентификаторов.</p><p>- PFFunc (binary): Имя функции PowerFactory.</p><p>- PFProjectParams (map): Параметры проекта.</p><p>&emsp;**Возвращает**: JSON-объект.</p><p>&emsp;**Пример использования**:</p><p>&emsp;JSON = fp\_powerfactory\_service\_old:get\_json(Config, OIDsByElement, <<"function\_name">>, PFProjectParams).</p>|
|http\_send/4|<p>: Отправляет HTTP-запрос на сервер PowerFactory.</p><p>**Параметры**:</p><p>- RemoteServiceParams (map): Параметры удалённого сервиса.</p><p>- Path (binary): Путь запроса.</p><p>- Data (binary): Тело запроса в формате JSON.</p><p>- ResponseFun (fun): Функция для обработки ответа.</p><p>&emsp;**Возвращает**: Результат выполнения запроса.</p><p>&emsp;**Пример использования**:</p><p>&emsp;fp\_powerfactory\_service\_old:http\_send(RemoteServiceParams, <<"api/path">>, Data, fun(Response) -> io:format("~p", [Response]) end).</p>|

**Примечания**

- Для корректной работы модуля необходимо наличие конфигурационного файла fp2pf\_mapping.json.
- Все функции обеспечивают обработку ошибок и логирование через макросы ?LOGINFO, ?LOGWARNING и ?LOGERROR.
- Методы HTTP-запросов используют библиотеку httpc для взаимодействия с удалёнными сервисами.

## <a name="_heading=h.4i7ojhp"></a>**Модуль fp\_state\_estimation\_service**
Сервис для оценки состояния (State Estimation, SE). Используется для вычисления текущего состояния системы, позволяя определять узкие места и потенциальные сбои в сети.

**Общая информация**

Модуль fp\_state\_estimation\_service предназначен для управления процессом оценивания состояния (state estimation) в системе. Он реализует экспорт и импорт данных в формате JSON, настройку и запуск вспомогательных утилит, а также предоставляет функции взаимодействия с хранилищами данных.

Этот модуль используется для интеграции системы управления с процессами анализа данных, включая передачу и обработку информации о параметрах узлов и линий, а также получение статистики работы системы.

|**Функция**|**Описание**|
| :-: | :-: |
|**on\_init/0**|<p>: Инициализирует API для вызова функций модуля через JSON-запросы. Функция должна быть вызвана при запуске системы.</p><p>**Параметры**: Нет.</p><p>**Возвращает**:</p><p>- ok — если инициализация завершилась успешно.</p><p>&emsp;**Пример использования**:</p><p>&emsp;fp\_state\_estimation\_service:on\_init().</p>|
|**export\_json/1**|<p>: Экспортирует данные системы в формате JSON, создавая файл для последующего анализа или передачи в другие модули.</p><p>**Параметры**:</p><p>- {StartParams, AParams, CommonSettingsPath, SSEStatPath}:</p><p>- StartParams — карта начальных параметров (например, временные диапазоны).</p><p>- AParams — дополнительные параметры (например, настройки фильтров).</p><p>- CommonSettingsPath — путь к объекту общих настроек.</p><p>- SSEStatPath — путь к объекту статистики.</p><p>&emsp;**Возвращает**:</p><p>- ok — если экспорт выполнен успешно.</p><p>- Логирует ошибку в случае сбоя при записи файла или при некорректных параметрах.</p><p>&emsp;**Пример использования**:</p><p>&emsp;StartParams = #{<<"start\_time">> => <<"2024-01-01T00:00:00">>, <<"end\_time">> => <<"2024-01-01T12:00:00">>},</p><p>&emsp;AParams = #{<<"region">> => <<"North">>},</p><p>&emsp;CommonSettingsPath = <<"/root/FP/PROJECT/settings/common">>,</p><p>&emsp;SSEStatPath = <<"/root/FP/PROJECT/statistics/se\_stats">>,</p><p>&emsp;</p><p>&emsp;fp\_state\_estimation\_service:export\_json({StartParams, AParams, CommonSettingsPath, SSEStatPath}).</p>|
|**import\_json/1**|<p>: Импортирует данные из JSON-файла в храниище данных системы. Используется для обновления информации о параметрах узлов, линий и статистики.</p><p>**Параметры**:</p><p>- SSEStatPath — путь к объекту статистики.</p><p>&emsp;**Возвращает**:</p><p>- ok — если импорт завершен успешно.</p><p>- Логирует ошибки при сбоях.</p><p>&emsp;**Пример использования**:</p><p>&emsp;SSEStatPath = <<"/root/FP/PROJECT/statistics/se\_stats">>,</p><p>&emsp;fp\_state\_estimation\_service:import\_json(SSEStatPath).</p>|
|**run\_se\_util/1**|<p>: Запускает утилиту для выполнения процессов state estimation.</p><p>**Параметры**:</p><p>- \_Arg — аргумент, зарезервированный для будущих реализаций (на текущий момент игнорируется).</p><p>&emsp;**Возвращает**:</p><p>- ok — если утилита выполнена успешно.</p><p>- Логирует предупреждение, если путь к утилите не указан.</p><p>&emsp;**Пример использования**:</p><p>&emsp;fp\_state\_estimation\_service:run\_se\_util({}).</p>|
|**run\_se/1**|<p>: Оркестрирует полный процесс запуска state estimation. Включает экспорт данных, запуск утилиты и последующий импорт результатов.</p><p>**Параметры**:</p><p>- {Path, StartParams, AParams, CommonSettingsPath, SSEStatPath}:</p><p>- Path — путь к рабочему каталогу.</p><p>- StartParams — начальные параметры.</p><p>- AParams — дополнительные параметры.</p><p>- CommonSettingsPath — путь к объекту настроек.</p><p>- SSEStatPath — путь к статистике.</p><p>&emsp;**Возвращает**:</p><p>- ok — если весь процесс завершен успешно.</p><p>- Логирует ошибки при сбоях.</p><p>&emsp;**Пример использования**:</p><p>&emsp;Path = <<"/home/master/forSE">>,</p><p>&emsp;StartParams = #{<<"start\_time">> => <<"2024-01-01T00:00:00">>},</p><p>&emsp;AParams = #{<<"region">> => <<"East">>},</p><p>&emsp;CommonSettingsPath = <<"/root/FP/PROJECT/settings/common">>,</p><p>&emsp;SSEStatPath = <<"/root/FP/PROJECT/statistics/se\_stats">>,</p><p>&emsp;</p><p>&emsp;fp\_state\_estimation\_service:run\_se({Path, StartParams, AParams, CommonSettingsPath, SSEStatPath}).</p>|
|**load\_config/0**|<p>: Загружает конфигурацию из JSON-файла state\_estimation\_settings.jsonc.</p><p>**Пример использования**:</p><p>Config = fp\_state\_estimation\_service:load\_config().</p>|
|**get\_absolute\_path/1**|<p>: Возвращает абсолютный путь к указанному файлу.</p><p>**Пример использования**:</p><p>AbsPath = fp\_state\_estimation\_service:get\_absolute\_path(<<"settings.jsonc">>).</p>|
|**load\_mapping/1**|<p>: Загружает настройки маппинга из файла.</p><p>**Пример использования**:</p><p>Mapping = fp\_state\_estimation\_service:load\_mapping(<<"mapping.jsonc">>).</p><p></p>|

**Примечания**

- Модуль интегрируется с внутренним хранилищем данных через протоколы, реализованные в платформе Faceplate.
- Все операции, связанные с чтением и записью, происходят транзакционно. В случае ошибки или сбоя транзакция откатывается.
- Для экспорта и импорта данных используются маппинг-файлы, описывающие соответствие структур данных системы и JSON.
- Перед использованием функций run\_se или run\_se\_util необходимо убедиться, что конфигурационные файлы и утилиты доступны.

## <a name="_heading=h.2xcytpi"></a>**Модуль string\_replace**
Модуль для работы с текстовыми данными. Включает функции поиска и замены текста, что полезно для обработки текстовой информации в системе.

**Общая информация**

Модуль string\_replace предназначен для выполнения замены подстрок в строках объектов хранилища данных. Замена производится рекурсивно по заданным шаблонам и паттернам. Основная цель модуля — автоматизация обновления строк с использованием хранилища данных fp\_db.

|**Функция**|**Описание**|
| :-: | :-: |
|**replace\_in\_strings/2**|<p>: Производит замену всех вхождений строки ?SEARCH\_STR на ?REPLACE\_STR для объектов, соответствующих заданным корню и паттерну.</p><p>**Параметры**:</p><p>- Root (binary) — корневая папка, в пределах которой ищутся объекты для обработки.</p><p>- Pattern (binary) — паттерн объектов, указывающий на их прототип.</p><p>&emsp;**Возвращает**:</p><p>- NewContent (list) — список объектов с обновленными строками.</p><p>&emsp;**Детали реализации**:</p><p>- Из хранилища данных fp\_db выбираются объекты, соответствующие указанным Root и Pattern.</p><p>- Для каждого объекта производится проверка наличия строки ?SEARCH\_STR в поле screen.</p><p>- Если строка найдена, она заменяется на ?REPLACE\_STR. Изменение сохраняется в хранилище данных.</p><p>- Если строка не содержит ?SEARCH\_STR, объект остается неизменным.</p><p>&emsp;**Пример использования**:</p><p>&emsp;% Выполнение замены строк в объектах с прототипом "/root/FP/prototypes/substation/fields" в папке "KAZ/UZHNIY".</p><p>&emsp;Root = <<"KAZ/UZHNIY">>,</p><p>&emsp;Pattern = <<"/root/FP/prototypes/substation/fields">>,</p><p>&emsp;string\_replace:replace\_in\_strings(Root, Pattern).</p>|
|**replace/2**|<p>: Выполняет замену строки ?SEARCH\_STR на ?REPLACE\_STR в заданном объекте.</p><p>**Параметры**:</p><p>- OID — идентификатор объекта.</p><p>- String — строка, в которой выполняется поиск и замена.</p><p>&emsp;**Возвращает**:</p><p>- Если замена произведена, функция возвращает новую строку с замененными подстроками.</p><p>- Если строка не содержит ?SEARCH\_STR, возвращается исходная строка.</p><p>&emsp;**Детали реализации**:</p><p>- Проверяется, содержит ли строка ?SEARCH\_STR с помощью binary:matches.</p><p>- Если вхождение найдено:</p><p>&emsp;1) Производится замена всех вхождений на ?REPLACE\_STR с помощью binary:replace\.</p><p>&emsp;2) Обновленная строка записывается обратно в объект через fp\_db:edit\_object\.</p><p>- Если вхождений нет, строка остается без изменений.</p><p>&emsp;**Пример использования**:</p><p>&emsp;OID = fp\_db:to\_oid(<<"example\_oid">>),</p><p>&emsp;String = <<"This is a lib.update\_line example">>,</p><p>&emsp;string\_replace:replace(OID, String).</p>|
|**replace\_in\_string/1**|<p>: Обрабатывает строки, проверяя их на наличие подстроки ?SEARCH\_STR. В случае наличия выполняет замену, используя функцию replace/2.</p><p>**Параметры**:</p><p>- [OID, String] — список, содержащий идентификатор объекта и строку для обработки.</p><p>&emsp;**Возвращает**:</p><p>- Обновленный список [OID, NewString], где NewString — результат замены.</p><p>&emsp;**Пример использования**:</p><p>&emsp;replace\_in\_string([OID, <<"lib.update\_line example">>]).</p>|

**Пример использования модуля:**

% Устанавливаем константы для поиска и замены

-define(SEARCH\_STR, "lib.update\_line").

-define(REPLACE\_STR, "lib.updateNode").

% Задаем корень и паттерн

Root = <<"KAZ/UZHNIY">>,

Pattern = <<"/root/FP/prototypes/substation/fields">>,

% Запускаем процесс замены

string\_replace:replace\_in\_strings(Root, Pattern).

**Вывод:**

- Если совпадение найдено:

  Замена произведена: /path/to/object

- Если совпадений не найдено:

  Совпадение не найдено в строке объекта /path/to/object

  **Примечания**

- Константы:

    1) ?SEARCH\_STR — строка, которую необходимо заменить\.

    2) ?REPLACE\_STR — строка, на которую выполняется замена\.

- Поддерживается обработка строк, заданных в бинарном формате.
- Логирование результатов замены осуществляется через io:format.

## <a name="_heading=h.1ci93xb"></a>**Модуль model\_service\_v2**
Новая версия сервиса для работы с моделями. Поддерживает управление несколькими архивами, а также интеграцию данных о погоде, предоставляя более широкие аналитические возможности.

**Общая информация**

Модуль model\_service\_v2 предназначен для выполнения заданий, связанных с обработкой данных моделей. Он предоставляет функционал для:

- Чтения данных из хранилища.
- Обработки данных с использованием внешних сервисов.
- Записи обработанных данных обратно в хранилище.

  Основной поток выполнения состоит из:

1. Подготовки данных для задачи.
1. Отправки данных на удалённый сервис.
1. Обработки ответа от сервиса.
1. Записи результата в хранилище данных.

|**Функция**|**Описание**|
| :-: | :-: |
|**run\_task/1**|<p>: Основная функция, запускающая выполнение задачи для указанного объекта. Производит полный цикл обработки: чтение, вызов внешнего сервиса и запись результата.</p><p>**Параметры**:</p><p>- Obj (OID объекта) — объект, для которого выполняется задача.</p><p>&emsp;**Возвращает**:</p><p>- ok — при успешном выполнении.</p><p>- {error, Reason} — при возникновении ошибки.</p><p>&emsp;**Детали реализации**:</p><p>- Считываются поля объекта, необходимые для выполнения задачи.</p><p>- Формируется набор временных меток для чтения данных из архива.</p><p>- Собирается JSON-запрос для внешнего сервиса.</p><p>- Выполняется HTTP-запрос на внешний сервис с заданными данными.</p><p>- Обрабатывается ответ от сервиса и записывается результат в хранилище данных.</p><p>&emsp;**Пример использования**:</p><p>&emsp;Obj = fp\_db:to\_oid(<<"object\_path">>),</p><p>&emsp;model\_service\_v2:run\_task(Obj).</p><p>&emsp;</p>|
|**call/2**|<p>: Функция для выполнения HTTP-запроса на внешний сервис.</p><p>**Параметры**:</p><p>- Url (binary) — URL сервиса.</p><p>- DataMap (map) — данные, отправляемые в теле запроса.</p><p>&emsp;**Возвращает**:</p><p>- {ok, Response} — успешный ответ от сервиса.</p><p>- {error, Reason} — ошибка при выполнении запроса.</p><p>&emsp;**Пример использования**:</p><p>&emsp;Url = <<"http://127.0.0.1:8000/predict">>,</p><p>&emsp;Data = #{<<"task\_id">> => <<"123">>, <<"task\_input">> => Dataset},</p><p>&emsp;model\_service\_v2:call(Url, Data).</p>|
|**read\_from\_db/3**|<p>: Считывает данные из архива за указанный временной диапазон.</p><p>**Параметры**:</p><p>- InputWindow (integer) — количество временных меток для чтения.</p><p>- Step (integer) — шаг между временными метками (в миллисекундах).</p><p>- Archive (OID) — архив, из которого считываются данные.</p><p>&emsp;**Возвращает**:</p><p>- Data (list) — список считанных данных.</p><p>- {error, Reason} — в случае ошибки.</p><p>&emsp;**Пример использования**:</p><p>&emsp;InputWindow = 24,</p><p>&emsp;Step = 3600000,  % 1 час</p><p>&emsp;Archive = fp\_db:to\_oid(<<"archive\_path">>),</p><p>&emsp;model\_service\_v2:read\_from\_db(InputWindow, Step, Archive).</p>|
|**write\_to\_db/2**|<p>: Записывает данные в архив.</p><p>**Параметры**:</p><p>- Data (list) — данные для записи.</p><p>- Archive (OID) — архив для записи данных.</p><p>&emsp;**Возвращает**:</p><p>- {ok, From, To} — диапазон временных меток записанных данных.</p><p>- {error, Reason} — ошибка при записи данных.</p><p>&emsp;**Пример использования**:</p><p>&emsp;Data = [{1669905600000, 1.23}, {1669909200000, 1.45}],</p><p>&emsp;Archive = fp\_db:to\_oid(<<"archive\_path">>),</p><p>&emsp;model\_service\_v2:write\_to\_db(Data, Archive).</p>|
|**transform/1**|<p>: Трансформирует данные в формат, подходящий для записи.</p><p>**Параметры**:</p><p>- Data (list) — входные данные.</p><p>&emsp;**Возвращает**:</p><p>- {ok, TransformedData} — успешная трансформация.</p><p>- {error, Reason} — ошибка трансформации.</p><p>&emsp;**Пример использования**:</p><p>&emsp;Data = [[1669905600, 1.23], [1669909200, 1.45]],</p><p>&emsp;model\_service\_v2:transform(Data).</p>|

**Пример использования модуля:**

% Устанавливаем объект

Obj = fp\_db:to\_oid(<<"object\_path">>),

% Запускаем выполнение задачи

model\_service\_v2:run\_task(Obj).

**Ожидаемый вывод в логах:**

1. Информация о начале задачи:

   model\_service: Run the task...

1. Успешное чтение данных:

   model\_service: read the object: #{<<"model\_state">> => <<"active">>, ...}

1. Успешный вызов внешнего сервиса:

   Response #{<<"task\_output">> => [[1669905600, 1.23], [1669909200, 1.45]]}

1. Успешная запись данных:

   Data successfully written to archive: <<"archive\_path">>

   **Примечания**

- Взаимодействие с внешним сервисом:

    1) URL сервиса формируется на основе хоста и порта\.

    2) Отправка данных осуществляется через HTTP POST запрос с JSON-телом\.

- Логирование:

    1) Все ключевые шаги процесса логируются с использованием макросов ?LOGINFO, ?LOGWARNING и ?LOGERROR\.

- Обработка ошибок:

  1)Если выполнение задачи прерывается на любом этапе, функция возвращает описание ошибки.

## <a name="_heading=h.3whwml4"></a>**Модуль rest\_api\_client (v1.0)**
Клиент REST API для обмена данными с системой рынка баланса. Поддерживает запросы на сервер по протоколу REST и позволяет интегрировать данные с внешними REST API.

**Общая информация**

Модуль rest\_api\_client предназначен для выполнения HTTP-запросов к REST API, включая:

1. Получение токена для авторизации.
1. Выполнение запросов с использованием токена.

|**Функция**|**Описание**|
| :-: | :-: |
|**get\_token/2**|<p>: Получает токен для авторизации по указанному URL и телу запроса.</p><p>**Параметры**:</p><p>- TokenUrl (binary) — URL для получения токена.</p><p>- RequestBody (map) — тело запроса с данными для авторизации.</p><p>&emsp;**Возвращает**:</p><p>- {ok, Token} — если токен успешно получен.</p><p>- {error, no\_token\_in\_response} — если токен отсутствует в ответе.</p><p>- {error, Reason} — если произошла ошибка во время выполнения запроса.</p><p>&emsp;**Детали реализации**:</p><p>- Формирует тело запроса в формате JSON.</p><p>- Выполняет POST-запрос на указанный URL.</p><p>- Декодирует ответ и извлекает токен.</p><p>&emsp;**Пример использования**:</p><p>&emsp;TokenUrl = <<"http://api.example.com/auth/token">>,</p><p>&emsp;RequestBody = #{<<"username">> => <<"user">>, <<"password">> => <<"pass">>},</p><p>&emsp;rest\_api\_client:get\_token(TokenUrl, RequestBody).</p>|
|**make\_request/4**|<p>: Выполняет HTTP-запрос с использованием токена авторизации.</p><p>**Параметры**:</p><p>- Token (binary) — токен для авторизации.</p><p>- Method (atom) — HTTP-метод (get, post, put, delete).</p><p>- Url (binary) — URL для выполнения запроса.</p><p>- Body (map) — тело запроса.</p><p>&emsp;**Возвращает**:</p><p>- {ok, Response} — успешный ответ с декодированными данными.</p><p>- {error, {unexpected\_status, Code}} — неожиданный статус-код.</p><p>- {error, Reason} — ошибка при выполнении запроса.</p><p>&emsp;**Детали реализации**:</p><p>- Кодирует тело запроса в формат JSON.</p><p>- Формирует HTTP-запрос с заголовками, включая Authorization.</p><p>- Выполняет запрос и обрабатывает результат.</p><p>&emsp;**Пример использования**:</p><p>&emsp;Token = <<"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9">>,</p><p>&emsp;Method = post,</p><p>&emsp;Url = <<"http://api.example.com/data">>,</p><p>&emsp;Body = #{<<"key">> => <<"value">>},</p><p>&emsp;rest\_api\_client:make\_request(Token, Method, Url, Body).</p>|
|**get\_url/3**|<p>: Формирует URL для выполнения запросов.</p><p>**Параметры**:</p><p>- Host (binary) — адрес хоста.</p><p>- Port (binary) — порт хоста.</p><p>- URL (binary) — конечная точка.</p><p>&emsp;**Возвращает**:</p><p>- Сформированный URL (binary).</p><p>&emsp;**Пример использования**:</p><p>&emsp;Host = <<"127.0.0.1">>,</p><p>&emsp;Port = <<"8080">>,</p><p>&emsp;Path = <<"api/resource">>,</p><p>&emsp;rest\_api\_client:get\_url(Host, Port, Path).</p>|

**Примеры использования модуля.**

**Пример 1: Получение токена**

TokenUrl = <<"http://auth.example.com/token">>,

RequestBody = #{<<"username">> => <<"admin">>, <<"password">> => <<"secret">>},

case rest\_api\_client:get\_token(TokenUrl, RequestBody) of

`    `{ok, Token} -> io:format("Token received: ~p~n", [Token]);

`    `{error, Reason} -> io:format("Failed to get token: ~p~n", [Reason])

end.

**Пример 2: Выполнение запроса с токеном**

Token = <<"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9">>,

Method = post,

Url = <<"http://api.example.com/resource">>,

Body = #{<<"param1">> => <<"value1">>, <<"param2">> => <<"value2">>},

case rest\_api\_client:make\_request(Token, Method, Url, Body) of

`    `{ok, Response} -> io:format("Response: ~p~n", [Response]);

`    `{error, Reason} -> io:format("Request failed: ~p~n", [Reason])

end.

**Пример 3: Формирование URL**

Host = <<"127.0.0.1">>,

Port = <<"8080">>,

Path = <<"api/v1/resource">>,

Url = rest\_api\_client:get\_url(Host, Port, Path),

io:format("Generated URL: ~p~n", [Url]).

**Ожидаемые сценарии работы**

- Успешный запрос:

    1) Токен получен и запрос выполнен без ошибок\.

    2) Ответ: {ok, Response}\.

- Ошибка токена:

    1) Сервер не вернул токен\.

    2) Ответ: {error, no\_token\_in\_response}\.

- Ошибка запроса:

    1) Сервер вернул неожиданный статус-код или произошла ошибка подключения\.

    2) Ответ: {error, Reason}\.

  **Примечания**

- Формат данных:

    1) Данные запросов и ответов кодируются/декодируются в формате JSON с помощью библиотеки jsx\.

- Авторизация:

    1) Используется авторизация с токеном, передаваемым в заголовке Authorization\.

- Обработка ошибок:

    1) Ошибки логируются, и в случае неудачного запроса возвращаются соответствующие коды и описания\.

## <a name="_heading=h.2bn6wsx"></a>**Модуль state\_graph (v1)**
Модуль для работы с графическим отображением состояний. Поддерживает функцию голосования (vote), позволяя принимать решения на основе текущих данных о состоянии объектов.

**Общая информация**

Модуль state\_graph предоставляет функционал для работы с цветами, связанными с состояниями и классами напряжения, извлечения класса напряжения из строки, а также вычисления среднего значения параметров из списка с учетом отклонений.

|**Функция**|**Описание**|
| :-: | :-: |
|**color/2**|<p>: Возвращает цвет в зависимости от класса напряжения и состояния.</p><p>**Параметры**:</p><p>- Vclass (integer) — класс напряжения.</p><p>- State (integer) — состояние.</p><p>&emsp;**Возвращает**:</p><p>- Цвет в виде строки (binary), например: <<"#959595">>.</p><p>&emsp;**Детали реализации**:</p><p>- Приводит State к числу, если это не так.</p><p>- Определяет цвет для заданного класса напряжения (Vclass) из предопределенной карты цветов.</p><p>- Возвращает цвет в зависимости от значения State.</p><p>&emsp;**Пример использования**:</p><p>&emsp;Vclass = 65,</p><p>&emsp;State = 2,</p><p>&emsp;state\_graph:color(Vclass, State).</p>|
|**get\_vclass\_from\_string/1**|<p>: Извлекает класс напряжения из строки.</p><p>**Параметры**:</p><p>- String (binary) — строка, содержащая класс напряжения.</p><p>&emsp;**Возвращает**:</p><p>- Класс напряжения (integer).</p><p>- 0, если класс напряжения не найден.</p><p>&emsp;**Детали реализации**:</p><p>1 Использует регулярное выражение для поиска чисел в строке.</p><p>2 Если совпадение найдено, преобразует его в число, иначе возвращает 0.</p><p>&emsp;**Пример использования**:</p><p>&emsp;String = <<"Voltage class: 110 kV">>,</p><p>&emsp;state\_graph:get\_vclass\_from\_string(String).</p>|
|**vote/3**|<p>: Вычисляет среднее значение параметров из списка, удовлетворяющих условию минимального отклонения от целевого значения.</p><p>**Параметры**:</p><p>- Values (list) — список чисел.</p><p>- Deviation (integer) — допустимое отклонение.</p><p>- TargetValue (integer) — целевое значение.</p><p>&emsp;**Возвращает**:</p><p>- Среднее значение (float) из фильтрованных значений.</p><p>- none, если подходящие значения отсутствуют.</p><p>&emsp;**Детали реализации**:</p><p>- Фильтрует значения, которые находятся в пределах Deviation от TargetValue.</p><p>- Если подходящих значений нет, возвращает none.</p><p>- Если одно значение удовлетворяет условию, возвращает его.</p><p>- Если несколько значений удовлетворяют условию, возвращает их среднее.</p><p>&emsp;**Пример использования**:</p><p>&emsp;Values = [110, 115, 120, 130],</p><p>&emsp;Deviation = 10,</p><p>&emsp;TargetValue = 115,</p><p>&emsp;state\_graph:vote(Values, Deviation, TargetValue).</p>|

**Примеры использования модуля**

**Пример 1: Определение цвета**

Vclass = 110,

State = 1,

Color = state\_graph:color(Vclass, State),

io:format("Цвет для класса напряжения ~p в состоянии ~p: ~p~n", [Vclass, State, Color]).

**Пример 2: Извлечение класса напряжения из строки**

String = <<"This is a voltage class: 220">>,

Vclass = state\_graph:get\_vclass\_from\_string(String),

io:format("Извлеченный класс напряжения: ~p~n", [Vclass]).

**Пример 3: Расчет среднего значения с учетом отклонений**

Values = [100, 105, 115, 130],

Deviation = 10,

TargetValue = 110,

Result = state\_graph:vote(Values, Deviation, TargetValue),

io:format("Среднее значение: ~p~n", [Result]).

**Ожидаемые сценарии работы**

- **Обработка цветов**: Если класс напряжения не найден в предопределенных значениях, возвращается цвет <<"#000000">> (черный). При некорректном состоянии (State) по умолчанию используется 0.
- **Извлечение данных из строки**: Если строка не содержит числовых данных, возвращается 0.
- **Фильтрация значений**: Если список значений пуст или не содержит подходящих элементов, возвращается none. При одном подходящем значении оно возвращается без изменений.

  **Примечания**

- **Обработка цветов**: Цвета ассоциируются с классами напряжения и состояниями, а если значения отсутствуют, используются цвета по умолчанию.
- **Работа со строками**: Класс напряжения извлекается из строки с помощью регулярных выражений.
- **Расчет среднего**: Фильтрация значений осуществляется на основе заданного допустимого отклонения.

# <a name="_heading=h.qsh70q"></a>**Подсистема EMS**
Эта документация поможет эффективно использовать API для работы с объектами, архивами и хранилищем данных в SCADA/EMS.
1. ## <a name="_heading=h.3as4poj"></a>**Модули fp и fp\_db (fp\_api\_erlang.md)**
**Общая информация**

Модули fp и fp\_db предназначены для работы с объектами, архивами и хранилищем данных в среде SCADA/EMS. API предоставляет методы для преобразования данных, работы с объектами, чтения и изменения полей, а также выполнения запросов.

Функции модуля оптимизированы для использования в RunTime и могут работать быстрее за счет кеширования данных.

|**Функция**|**Описание**|
| - | - |
|fp:to\_json/1|<p>**:** Преобразует Erlang-терм (список, map, числа) в JSON.</p><p>**Возвращает:** binary в формате JSON.</p><p>**Пример использования:**</p><p>JSON = fp:to\_json(#{key => "value"}).</p>|
|fp:from\_json/1|<p>**:** Конвертирует JSON (в формате binary) обратно в Erlang-терм.<br>**Возвращает:** Термин (например, список, map, числа).</p><p>**Пример использования:**</p><p>Term = fp:from\_json(<<"{\"key\":\"value\"}">>).</p>|
|fp:open\_tag/1|<p>**:** Открывает объект тега по указанному пути. Работает быстрее fp\_db:open/1, благодаря кешированию.</p><p>**Требование:** Работает только в режиме RunTime.</p><p>**Возвращает:** {ok, Object}.</p><p>**Пример использования:**</p><p>{ok, Tag} = fp:open\_tag("/path/to/tag").</p>|
|fp:get\_value/2|<p>**:** Получает значение поля объекта по пути к тегу. Работает быстрее, чем fp\_db:read\_field.</p><p>**Требование:** Работает только в режиме RunTime.</p><p>**Возвращает:** {ok, Value}.</p><p>**Пример использования:**</p><p>{ok, Value} = fp:get\_value(Tag, Field).</p>|
|fp:get\_value/3|<p>**:** Аналог fp:get\_value/2, но возвращает значение Default, если поле не задано.</p><p>**Возвращает:** {ok, Value}.</p><p>**Пример использования:**</p><p>{ok, Value} = fp:get\_value(Tag, Field, DefaultValue).</p>|
|fp:set\_value/2|<p>**:** Изменяет значения полей тега.</p><p>**Требование:** Работает только в режиме RunTime.</p><p>**Принимает:**</p><p>- TagPath — путь к тегу.</p><p>- Changes — список пар {Field, Value}.</p><p>&emsp;**Возвращает:** ok.</p><p>&emsp;**Пример использования:**</p><p>&emsp;ok = fp:set\_value("/path/to/tag", [{field1, value1}, {field2, value2}]).</p>|
|fp:set\_value/3|<p>**:** Присваивает конкретное значение полю объекта.</p><p>**Требование:** Работает только в режиме RunTime.</p><p>**Возвращает:** ok.</p><p>**Пример использования:**</p><p>ok = fp:set\_value("/path/to/tag", field, value).</p>|
|fp:archives\_get/2|<p>**:** Возвращает значения архивов для указанных точек в заданных моментах времени.</p><p>**Возвращает:** Список списков формата:</p><p>` `[[TS1, A1\_value, A2\_value, ...], ...].</p><p>**Пример использования:**</p><p>Data = fp:archives\_get(Points, Archives).</p>|
|fp:archive\_get\_point/2|<p>**:** Получает значение из архива в заданный момент времени.</p><p>**Возвращает:** {TS, Value}.</p><p>**Пример использования:**</p><p>{Timestamp, Value} = fp:archive\_get\_point(Archive, Timestamp).</p>|
|fp:archives\_get\_periods/2|<p>**:** Возвращает значения архивов за периоды, настроенные через Params.</p><p>**Возвращает:** Список списков формата:</p><p>` `[[TS1, A1\_value, A2\_value, ...], ...].</p><p>**Пример использования:**</p><p>Data = fp:archives\_get\_periods(Params, Archives).</p>|
|fp:version/0|<p>**:** Возвращает текущую версию API.</p><p>**Возвращает:** Версию в формате Version.</p><p>**Пример использования:**</p><p>Version = fp:version().</p>|
|fp\_db:create\_object/1|<p>**:** Создаёт объект с заданными полями.</p><p>**Возвращает:** Объект.</p><p>**Пример использования:**</p><p>Object = fp\_db:create\_object(#{field1 => value1, field2 => value2}).</p>|
|fp\_db:read\_field/2|<p>**:** Читает значение поля объекта.</p><p>**Возвращает:** {ok, Value}.</p><p>**Пример использования:**</p><p>{ok, Value} = fp\_db:read\_field(Object, Field).</p>|
|fp\_db:read\_field/3|<p>**:** Читает значение поля объекта с дополнительными параметрами.</p><p>**Возвращает:** {ok, Value}.</p><p>**Пример использования:**</p><p>{ok, Value} = fp\_db:read\_field(Object, Field, Params).</p>|
|fp\_db:read\_fields/2|<p>**:** Читает сразу несколько полей объекта.</p><p>**Возвращает:** Map с парами #{Field => Value}.</p><p>**Пример использования:**</p><p>Fields = fp\_db:read\_fields(Object, [field1, field2]).</p>|
|fp\_db:edit\_object/2|<p>**:** Изменяет значения полей объекта.</p><p>**Возвращает:** ok.</p><p>**Пример использования:**</p><p>ok = fp\_db:edit\_object(Object, #{field => value}).</p>|
|fp\_db:query/1|<p>**:** Выполняет запрос к хранилищу данных (Ecomet).</p><p>**Возвращает:** Результат запроса.</p><p>**Пример использования:**</p><p>Result = fp\_db:query(Query).</p>|

**Примечания**

- **RunTime:** Некоторые функции (fp:open\_tag, fp:get\_value, fp:set\_value) работают только в режиме RunTime.
- **Кеширование:** Функции fp оптимизированы за счёт использования кеша, что делает их быстрее аналогов из fp\_db.
- **Совместимость:** Архивные функции (fp:archives\_get, fp:archive\_get\_point) совместимы с функциями из fp\_archive.

## <a name="_heading=h.1pxezwc"></a>**Модуль функций JavaScript (fp\_api\_js.md)**
**Общая информация**

fp\_api\_js предоставляет функции для взаимодействия с объектами SCADA-системы на базе JavaScript. Используйте функции для работы с тегами, хранилищем данных и архивами.

**Общие рекомендации**

- **Асинхронность:** Все функции API возвращают промисы. Для получения результата используйте await.
- **Идентификаторы объектов:** Вместо путей к тегам можно использовать идентификаторы объектов, полученные при создании.

|**Функция**|**Описание**|
| :-: | :-: |
|**Работа с тегами**||
|fp.api.get\_value(path, field)|<p>: Получает значение заданного поля тега.</p><p>**Параметры:**</p><p>- path (string): Путь к тегу.</p><p>- field (string): Поле тега, значение которого необходимо получить.</p><p>&emsp;**Возвращает:**</p><p>- Значение поля.</p><p>&emsp;**Пример использования:**</p><p>&emsp;let value = await fp.api.get\_value('/root/PROJECT/TAGS/AI', 'value');</p>|
|fp.api.set\_value(path, field, value)|<p>: Устанавливает значение поля тега.</p><p>**Параметры:**</p><p>- path (string): Путь к тегу.</p><p>- field (string): Поле тега.</p><p>- value (any): Значение, которое нужно записать.</p><p>&emsp;**Возвращает:** undefined.</p><p>&emsp;**Пример использования:**</p><p>&emsp;fp.api.set\_value('/root/PROJECT/TAGS/AI', 'value', 10.5);</p>|
|fp.api.archives\_get(timestamps, archives)|<p>: Получает данные из архива для указанных временных точек.</p><p>**Параметры:**</p><p>- timestamps (array): Массив временных точек.</p><p>- archives (array): Массив массивов, где каждый элемент: [путь к архиву, агрегирующая функция].</p><p>&emsp;**Возвращает:**</p><p>- Массив массивов, содержащих временные метки и значения.</p><p>&emsp;**Пример использования:**</p><p>&emsp;let data = await fp.api.archives\_get(</p><p>&emsp;`    `[TS1, TS2, TS3],</p><p>&emsp;`    `[["/root/PROJECT/TAGS/archive\_1", "avg"]]</p><p>&emsp;);</p>|
|**Работа с хранилищем данных**||
|fp.db.create\_object(params)|<p>: Создает новый объект.</p><p>**Параметры:**</p><p>- params (object): Параметры объекта, включая .name, .folder, .pattern и дополнительные поля.</p><p>&emsp;**Возвращает:**</p><p>- Идентификатор созданного объекта.</p><p>&emsp;**Пример использования:**</p><p>&emsp;let obj = await fp.db.create\_object({</p><p>&emsp;`    `".name": "mytag",</p><p>&emsp;`    `".folder": "/root/PROJECT/TAGS/folder",</p><p>&emsp;`    `".pattern": "/root/.patterns/AI",</p><p>&emsp;`    `"value": 1.0</p><p>&emsp;});</p>|
|fp.db.read\_field(object, field)|<p>: Читает значение поля объекта.</p><p>**Параметры:**</p><p>- object (string | ID): Путь или идентификатор объекта.</p><p>&emsp;- field (string): Название поля.</p><p>&emsp;&emsp;**Возвращает:**</p><p>&emsp;- Значение поля.</p><p>&emsp;&emsp;**Пример использования:**</p><p>&emsp;&emsp;let value = await fp.db.read\_field('/root/PROJECT/TAGS/AI', 'value');</p>|
|fp.db.edit\_object(object, changes)|<p>: Редактирует существующий объект.</p><p>**Параметры:**</p><p>- object (string | ID): Путь или идентификатор объекта.</p><p>&emsp;- changes (object): Изменяемые поля и их новые значения.</p><p>&emsp;&emsp;**Возвращает:** undefined.</p><p>&emsp;&emsp;**Пример использования:**</p><p>&emsp;&emsp;fp.db.edit\_object('/root/PROJECT/TAGS/AI', { value: 1.0, title: "Updated" });</p>|
|fp.db.delete\_object(object)|<p>: Удаляет объект.</p><p>**Параметры:**</p><p>- object (string | ID): Путь или идентификатор объекта.</p><p>&emsp;&emsp;**Возвращает:** undefined.</p><p>&emsp;&emsp;**Пример использования:**</p><p>&emsp;&emsp;fp.db.delete\_object('/root/PROJECT/TAGS/AI');</p>|
|**Работа с транзакциями**||
|fp.db.start\_transaction()|<p>: Начинает транзакцию.</p><p>**Пример использования:**</p><p>fp.db.start\_transaction();</p>|
|fp.db.commit\_transaction()|<p>: Фиксирует транзакцию.</p><p>**Пример использования:**</p><p>fp.db.commit\_transaction();</p>|
|fp.db.rollback\_transaction()|<p>: Откатывает транзакцию.</p><p>**Пример использования:**</p><p>fp.db.rollback\_transaction();</p>|

**Примечание**

- Используйте функции API только в асинхронном контексте (async).
- Примерный список агрегирующих функций для работы с архивами: min, max, avg, sum, steps, categories.
- Некоторые функции (dirty\_edit\_object) работают быстрее за счет отсутствия проверок, но требуют повышенной осторожности.

## <a name="_heading=h.49x2ik5"></a>**Модуль функций для работы с базой данных (fp\_sql.md)**
**Общая информация**

fp\_sql предоставляет инструменты для подключения к реляционным базам данных через ODBC, используя модуль odbc в Erlang.

Этот механизм позволяет выполнять SQL-запросы к базам данных PostgreSQL, MSSQL и другим, поддерживающим ODBC-драйвера.

Модуль можно использовать в пользовательских скриптах и консоли Erlang.

|**Функция**|**Описание**|
| :-: | :-: |
|odbc:start().|: Инициализирует модуль odbc. Это обязательный шаг перед использованием функций модуля.|
|{ok, Ref} = odbc:connect(ConnectionString, Options).|<p>: Подключает к базе данных.</p><p>**Параметры:**</p><p>- ConnectionString: строка подключения ODBC.</p><p>- Options: список параметров подключения.</p><p>&emsp;**Возвращает:**</p><p>- Кортеж {ok, Ref} — успешное подключение, где Ref — ссылка на соединение.</p><p>- error — если подключение не удалось.</p><p>&emsp;**Пример использования:**</p><p>&emsp;erlang</p><p>&emsp;Копировать код{ok, Ref} = odbc:connect(</p><p>&emsp;`    `"Driver={/usr/lib/x86\_64-linux-gnu/odbc/psqlodbca.so};Server=192.168.2.158;Port=5432;Database=BZ2;Uid=postgres;Pwd=2312;",</p><p>&emsp;`    `[]</p><p>&emsp;).</p>|
|Result = odbc:sql\_query(Ref, SQLQuery).|<p>: Выполняет SQL-запрос.</p><p>**Параметры:**</p><p>- Ref: ссылка на соединение.</p><p>- SQLQuery: строка с SQL-запросом.</p><p>&emsp;**Возвращает:**</p><p>- Результаты выполнения SQL-запроса.</p><p>&emsp;**Пример использования:**</p><p>&emsp;Result = odbc:sql\_query(Ref, "SELECT \* FROM table").</p>|
|odbc:disconnect(Ref).|<p>: Закрывает соединение с базой данных.</p><p>**Параметры:**</p><p>- Ref: ссылка на соединение.</p><p>&emsp;**Пример использования:**</p><p>&emsp;odbc:disconnect(Ref).</p>|
|odbc:stop().|<p>: Завершает работу модуля odbc.</p><p>**Пример использования:**</p><p>odbc:stop().</p>|

**Примеры использования**

**Пример подключения к PostgreSQL**

odbc:start().

{ok, Ref} = odbc:connect(

`    `"Driver={/usr/lib/x86\_64-linux-gnu/odbc/psqlodbca.so};Server=192.168.2.158;Port=5432;Database=BZ2;Uid=postgres;Pwd=2312;",

`    `[]

).

Result = odbc:sql\_query(Ref, "SELECT \* FROM table").

odbc:disconnect(Ref).

odbc:stop().

**Пример подключения к MSSQL**

odbc:start().

{ok, Ref} = odbc:connect(

`    `"Driver=/usr/lib/x86\_64-linux-gnu/odbc/libtdsodbc.so;Server=192.168.210.172,1433;Database=remont;Uid=wacs;Pwd=wacs;",

`    `[]

).

Result = odbc:sql\_query(Ref, "SELECT \* FROM remont.utpo.r\_ORZ").

odbc:disconnect(Ref).

odbc:stop().

**Примечания**

- **Подготовка системы:** Для работы с ODBC необходимо установить драйверы:

  *PostgreSQL:*

  sudo apt-get install unixodbc odbc-postgresql

  *MSSQL:*

  sudo apt-get install unixodbc tdsodbc

- **Кодировки MSSQL:** В некоторых случаях требуется указать параметр use\_unicode=true в строке подключения, чтобы избежать проблем с кодировкой:

  {ok, Ref} = odbc:connect(

  `    `"Driver=/usr/lib/x86\_64-linux-gnu/odbc/libtdsodbc.so;Server=192.168.210.172,1433;Database=remont;Uid=wacs;Pwd=wacs;use\_unicode=true",

  `    `[]

  ).

- **Пути драйверов:** Проверьте, что драйверы установлены в правильных папках:

  /usr/lib/x86\_64-linux-gnu/odbc/

  /opt/microsoft/msodbcsql17/lib64/

- **Официальная документация и справка:**

  https://docs.microsoft.com/en-us/sql/connect/odbc/

  https://www.connectionstrings.com/