# Прототипы

Понятие прототипов в IoT-платформах, таких как Faceplate, схоже с концепцией классов в объектно-ориентированном программировании. Другими словами они представляют собой шаблоны или формы для создания конкретных экземпляров объектов или устройств, определяя их структуру, свойства, содержимое и поведение. Это означает, что прототип включает в себя определение полей, их типы данных, методы и функции для работы с этими полями, а также логику для обработки событий и состояний объекта.
Прототип является основой для создания конкретных экземпляров объектов или устройств в системе. Каждый экземпляр прототипа наследует его свойства и методы, а также может иметь собственные уникальные значения для полей.
Прототип позволяет стандартизировать создание и управление объектами в IoT-платформе, обеспечивая повторное использование кода и упрощая разработку и сопровождение системы. Он также определяет интерфейс для взаимодействия с объектами и устройствами, что упрощает интеграцию и расширение функциональности системы.

Вот несколько концепций использования прототипов:
1.	Ключ к созданию: Прототипы подобны образцам или черновикам, которые облегчают создание новых объектов или устройств. Они предоставляют основу, на которой можно основываться при создании новых экземпляров, помогая избежать повторения кода и ускоряя процесс разработки.
2.	Модель для копирования: Прототипы можно рассматривать как модели, которые можно копировать для создания новых объектов с аналогичными характеристиками. Подобно тому, как можно использовать форму для создания нескольких копий одного документа, прототипы позволяют создавать множество экземпляров объектов, сохраняя их общие свойства и функциональность.
3.	Стандартизация и единообразие: Прототипы помогают стандартизировать создание и управление объектами в системе, обеспечивая единообразие в структуре и поведении. Подобно тому, как шаблоны помогают сохранить единообразие дизайна в различных документах, прототипы обеспечивают согласованность в представлении и функциональности объектов в системе.
4.	Упрощение изменений и обновлений: Поскольку прототипы определяют общие характеристики объектов, изменения, внесенные в прототип, автоматически распространяются на все его экземпляры. Это облегчает внесение изменений и обновлений в систему, так же как изменения в шаблоне документа могут быть применены ко всем его копиям.
      Использование в IoT-платформах
      Вот несколько причин, по которым прототипы могут быть полезны в IoT-платформах:
1.	Ускорение разработки: Создание прототипов позволяет быстро оценить функциональность системы и визуализировать её работу. Это помогает разработчикам быстрее перейти к созданию рабочих версий системы.
2.	Гибкость и масштабируемость: Использование прототипов обеспечивает гибкость при добавлении новых функций или изменении существующих. Это позволяет быстро адаптировать систему к изменяющимся требованиям.
3.	Уменьшение рисков: Прототипирование позволяет выявить потенциальные проблемы или недочеты в дизайне системы на ранних этапах разработки. Это позволяет снизить риски и улучшить качество конечного продукта.
4.	Разделение ответственности: Использование прототипов может помочь разделить функциональность системы на более мелкие компоненты, каждый из которых может быть разработан и тестирован независимо. Это способствует более эффективному управлению проектом.
5.	Повышение понимания: Создание прототипов помогает участникам проекта лучше понять требования и ожидания от системы. Визуализация работы системы на ранних этапах разработки может привести к более точному пониманию её функциональности.
      Можно сделать вывод, что прототипы в IoT-платформах помогают ускорить процесс разработки, снизить риски и улучшить качество конечного продукта, делая разработку более эффективной и управляемой.

Рассмотрим несколько практических примеров использования прототипов в IoT-платформах с определением поведения с помощью скриптов:
1.	Прототип объекта устройства: Предположим, что в SCADA-системе необходимо работать с различными типами устройств, такими как насосы, клапаны, датчики и т.д. Создание прототипа класса устройства позволит определить общие характеристики и функциональность для всех типов устройств. С использованием скриптов, например, на основе JavaScript или Erlang, можно создать экземпляры этих устройств и определить их поведение в зависимости от различных условий (например, управление насосом в зависимости от уровня жидкости).
2.	Прототип объекта сети: В IoT-платформах часто необходимо взаимодействовать с различными сетевыми устройствами, такими как контроллеры, коммутаторы и т.д. Создание прототипа класса сетевого устройства позволяет определить общие методы и свойства для работы с такими устройствами. С помощью скриптов можно автоматизировать задачи связи с этими устройствами, например, сбор данных о состоянии и управление ими.
3.	Прототип объекта события: В IoT-платформах события играют важную роль, например, предупреждения о проблемах в работе оборудования или изменениях в процессах. Создание прототипа класса события позволяет определить общие характеристики и методы обработки событий. С помощью скриптов можно определить поведение системы при возникновении определенных событий, например, отправку уведомлений администратору или запуск аварийных процедур.
4.	Прототип объекта данных: В IoT-платформах данные играют ключевую роль, так как они представляют информацию о состоянии оборудования, процессов и событий. Создание прототипа класса данных позволяет определить общие методы и свойства для работы с данными. С использованием скриптов можно выполнять различные операции с данными, например, фильтрацию, агрегацию или анализ.
      Создание прототипа
      Прототип можно создать на вкладке прототипы
      Proto1.png
      Кнопка	Описание
      Proto1.1.png	Кнопка обновления списка прототипов для получения актуальной информации, в том случае, когда с одним проектом работает несколько клиентов.
      Proto1.2.png	Кнопка создания прототипа. При создании прототипа появляется окно: Proto2.png
      Proto1.3.png	Кнопка редактирования прототипа
      Proto1.4.png	Кнопка удаления прототипа
      Proto1.5.png	Кнопка копирования прототипа
      Proto1.6.png	Кнопка вставки прототипа
      Proto1.7.png	Кнопка редактора прототипа
      Proto1.8.png	Кнопка экспорта в базу в формате .xlsx файла
      Proto1.9.png	Импорт из базы в формате .xlsx файла
      Proto1.10.png	Кнопка экспорта проекта в файл
      Proto1.11.png	Кнопка импорта проекта из файла

При создании прототипа появляется окно:
Proto2.png
Указание группы при создании прототипа в IoT-платформе или SCADA-системе может иметь несколько значений и целей, в зависимости от контекста и специфики системы. Вот несколько возможных интерпретаций значения указания группы:
1.	Организация и классификация: Группа может служить для организации и классификации прототипов по их функциональному или логическому назначению. Например, прототипы устройств могут быть сгруппированы по типу (например, датчики, актуаторы, контроллеры), а прототипы событий - по категориям (например, предупреждения, аварии, информационные сообщения).
2.	Управление доступом и правами: Группировка прототипов может использоваться для управления доступом и правами пользователей. Например, администраторы могут иметь доступ к прототипам всех групп, в то время как обычные пользователи могут иметь доступ только к определенным группам, связанным с их функциональными обязанностями.
3.	Контроль версий и жизненного цикла: Группы могут также использоваться для контроля версий и управления жизненным циклом прототипов. Например, прототипы одной группы могут быть связаны с конкретной версией проекта или продукта, а другие - с тестовыми или экспериментальными версиями.
4.	Организация процесса разработки и управления проектами: Группы могут помочь организовать процесс разработки и управления проектами, разделяя прототипы на логические блоки или модули, которые могут быть разработаны и тестированы независимо друг от друга.
      В целом, указание группы при создании прототипа позволяет более эффективно организовать и управлять различными аспектами системы, такими как классификация, доступ, версии и процесс разработки.

Behavior - это скрипт, который отрабатывается при изменении (создание, редактирование, удаление) Прототипа.



Пример вывода:


Образец скрипта:
```shell
%%-----------------------------------------------------------------
%% This script is executed at the server side. The programming language
%% is Erlang.
%% The module MUST export next 3 methods:
%% * on_create/1 - this method is called when a new instance of the prototype is created.
%% * on_edit/1 - this method is called when own fields of an instance of the prototype are edited
%% * on_delete/1 - this method is called when an instance of the prototype is deleted
%% All this methods accept an Object of the instance and can edit or perform any other allowed code.
%% If any of the methods throw or crash the whole transaction will rollback.
%% If there are any warnings or not critical errors it is recommended to log them with available macros, examples:
%% ?LOGWARNING( "my warning text: ~p", [Warning] )
%% ?LOGERROR( "my error text: ~p", [Error] )
%% If the methods performs well it should return atom 'ok'.
%% For more info please refer to the documentation
%%-----------------------------------------------------------------
-module(fp_prototype_MyProto1).

-include("fp_struct.hrl").

-export([
on_create/1,
on_delete/1,
on_edit/1
]).

on_create(_Object)->
ok.

on_edit(_Object)->
ok.

on_delete( Object )->
ok.
```
Рассмотрим примеры создания скриптов, определяющих поведение прототипа на языке Erlang.
Пример 1:
```shell
%%----------------------------------------------------------------- 
%% This script is executed at the server side. The programming language 
%% is Erlang. 
%% The module MUST export next 3 methods: 
%% * on_create/1 - this method is called when a new instance of the prototype is created. 
%% * on_edit/1 - this method is called when own fields of an instance of the prototype are edited 
%% * on_delete/1 - this method is called when an instance of the prototype is deleted 
%% All these methods accept an Object of the instance and can edit or perform any other allowed code. 
%% If any of the methods throw or crash, the whole transaction will rollback. 
%% If there are any warnings or non-critical errors, it is recommended to log them with available macros, examples: 
%% ?LOGWARNING( "my warning text: ~p", [Warning] ) 
%% ?LOGERROR( "my error text: ~p", [Error] ) 
%% If the methods perform well, they should return the atom 'ok'. 
%% For more info, please refer to the documentation 
%%----------------------------------------------------------------- 
-module(fp_prototype_MyProto1). 

-include("fp_struct.hrl"). 

-export([ 
   on_create/1, 
   on_delete/1, 
   on_edit/1 
   ]). 

on_create(Object) -> 
   io:format("Instance of MyProto1 created: ~p~n", [Object]), 
   ok. 
   
on_edit(Object) -> 
   io:format("Fields of MyProto1 instance edited: ~p~n", [Object]), 
   ok. 
   
on_delete(Object) -> 
   io:format("Instance of MyProto1 deleted: ~p~n", [Object]), 
   ok.
```
Этот скрипт реализует три метода: on_create, on_edit и on_delete, которые вызываются при создании, изменении и удалении экземпляра прототипа соответственно. В данном примере эти методы просто выводят сообщение в консоль, указывая на то, что произошло с экземпляром. Вы можете дополнить их логикой, соответствующей вашим требованиям.
Пример 2.
Давайте расширим последний скрипт для работы с прототипом, представляющим конкретное устройство. Для примера давайте предположим, что у нас есть прототип устройства, представляющего насос, и мы хотим, чтобы наш скрипт выполнял определенные действия в зависимости от состояния этого насоса.
```shell
%%----------------------------------------------------------------- 
%% This script is executed at the server side. The programming language 
%% is Erlang. 
%% The module MUST export next 3 methods: 
%% * on_create/1 - this method is called when a new instance of the prototype is created. 
%% * on_edit/1 - this method is called when own fields of an instance of the prototype are edited 
%% * on_delete/1 - this method is called when an instance of the prototype is deleted 
%% All these methods accept an Object of the instance and can edit or perform any other allowed code. 
%% If any of the methods throw or crash, the whole transaction will rollback. 
%% If there are any warnings or non-critical errors, it is recommended to log them with available macros, examples: 
%% ?LOGWARNING( "my warning text: ~p", [Warning] ) 
%% ?LOGERROR( "my error text: ~p", [Error] ) 
%% If the methods perform well, they should return the atom 'ok'. 
%% For more info, please refer to the documentation 
%%----------------------------------------------------------------- 
-module(fp_prototype_Pump). 

-include("fp_struct.hrl"). 

-export([ 
   on_create/1, 
   on_delete/1, 
   on_edit/1 
]). 

-define(PUMP_STATE_NORMAL, 0). 
-define(PUMP_STATE_WARNING, 1). 
-define(PUMP_STATE_ERROR, 2). 

on_create(Object) -> 
   io:format("Pump instance created: ~p~n", [Object]), 
   ok. 
on_edit(Object) -> 
   % Проверяем состояние насоса и выполняем соответствующие действия 
   case Object#pump.state of 
      ?PUMP_STATE_NORMAL -> 
         io:format("Pump is in normal state: ~p~n", [Object]), 
         ok; 
      ?PUMP_STATE_WARNING -> 
         io:format("Pump is in warning state: ~p~n", [Object]), 
         ok; 
      ?PUMP_STATE_ERROR -> 
         io:format("Pump is in error state: ~p~n", [Object]), 
         ok 
   end. 
   
on_delete(Object) -> 
   io:format("Pump instance deleted: ~p~n", [Object]), 
   ok.
```
Этот скрипт добавляет обработку состояния насоса в методе on_edit. В зависимости от состояния насоса он выводит соответствующее сообщение в консоль. Вы можете дополнить скрипт логикой обработки состояний насоса, включая отправку уведомлений, запись в журнал или выполнение дополнительных действий.

Пример 3.

Прототипы в SCADA-системах часто имеют набор полей, которые определяют их свойства и характеристики. Для дать определение прототипа на основании этого, мы можем добавить определение полей в Erlang-модуль прототипа. Вот пример определения прототипа на основании всего выше перечисленного:
```shell
%%----------------------------------------------------------------- 
%% This script is executed at the server side. The programming language 
%% is Erlang. 
%% The module MUST export next 3 methods: 
%% * on_create/1 - this method is called when a new instance of the prototype is created. 
%% * on_edit/1 - this method is called when own fields of an instance of the prototype are edited 
%% * on_delete/1 - this method is called when an instance of the prototype is deleted 
%% All these methods accept an Object of the instance and can edit or perform any other allowed code. 
%% If any of the methods throw or crash, the whole transaction will rollback. 
%% If there are any warnings or non-critical errors, it is recommended to log them with available macros, examples: 
%% ?LOGWARNING( "my warning text: ~p", [Warning] ) 
%% ?LOGERROR( "my error text: ~p", [Error] ) 
%% If the methods perform well, they should return the atom 'ok'. 
%% For more info, please refer to the documentation 
%%----------------------------------------------------------------- 
-module(fp_prototype_Pump). 

-include("fp_struct.hrl"). 

-export([ 
   on_create/1, 
   on_delete/1, 
   on_edit/1 
]). 

-record(pump, { 
   id :: string(), 
   name :: string(), 
   type :: string(), 
   state :: integer() 
}). 

-define(PUMP_STATE_NORMAL, 0). 
-define(PUMP_STATE_WARNING, 1). 
-define(PUMP_STATE_ERROR, 2). 

on_create(Object) -> 
   io:format("Pump instance created: ~p~n", [Object]), 
   ok. 
   
on_edit(Object) -> 
   % Проверяем состояние насоса и выполняем соответствующие действия 
   case Object#pump.state of 
      ?PUMP_STATE_NORMAL -> 
         io:format("Pump is in normal state: ~p~n", [Object]), 
         ok; 
      ?PUMP_STATE_WARNING -> 
         io:format("Pump is in warning state: ~p~n", [Object]), 
         ok; 
      ?PUMP_STATE_ERROR -> 
         io:format("Pump is in error state: ~p~n", [Object]), 
         ok 
   end. 
   
on_delete(Object) -> 
   io:format("Pump instance deleted: ~p~n", [Object]), 
   ok.
```
В этом примере добавлено определение полей прототипа pump, включая id, name, type и state. Для каждого поля указан тип данных. Теперь прототип насоса имеет определенную структуру данных, которая позволяет представлять его свойства и характеристики.
