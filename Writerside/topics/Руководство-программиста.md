# Руководство программиста

# **Введение**
Faceplate (FP) Studio предоставляет возможности для создания скриптов, которые позволяют добавлять новую функциональность и определять поведение различных компонентов системы, таких как прототипы, архивы, IoT-подключения и другие. Эти скрипты выполняют широкий спектр задач, включая обработку данных, взаимодействие с внешними API, выполнение вычислений, настройку параметров и автоматизацию процессов в SCADA-системе.

Для написания скриптов в Faceplate Studio поддерживаются два языка:

- **Erlang** — используется для выполнения задач на стороне сервера, таких как управление данными, взаимодействие с хранилищами данных и системами архивирования. Описание встроенных функций erlang можно посмотреть https://www.erlang.org/doc/system/reference\_manual.html.
- **JavaScript** — применяется для выполнения клиентских операций, включая обработку данных и управление интерфейсными элементами. Описание поддерживаемых в FP функций JavaScript можно посмотреть <https://ecma-international.org/publications-and-standards/standards/ecma-262/>.

  Данное руководство содержит основные принципы написания скриптов, объяснение структуры, примеры их применения, а также описание функций библиотечных модулей. Информация, изложенная здесь, поможет разработчикам легко создавать скрипты для решения задач в системе Faceplate, обеспечивая удобство и гибкость в работе с системой.

  ## <a name="_heading=h.3znysh7"></a>**1.1 Общие рекомендации по написанию скриптов**
- **Логирование и обработка ошибок**: Используйте макросы ?LOGINFO, ?LOGWARNING и ?LOGERROR для логирования информации и обработки ошибок (файл console.log). Для логирования в самом журнале сообщений используйте макросы ? FP\_LOGINFO, ? FP\_LOGWARNING и ? FP\_LOGERROR.
- **Отладка и тестирование**: После написания скрипта необходимо провести компиляцию. В случае успешного выполнения появится сообщение “ok”; в противном случае будут указаны ошибки.
- **Привязка скриптов**: Привязывайте скрипты к конкретным объектам или параметрам для автоматической обработки данных или выполнения операций на основе триггеров.

  ## <a name="_heading=h.2et92p0"></a>**1.2 Основные возможности скриптов в Faceplate Studio**
  Скрипты можно разделить на несколько типов в зависимости от их сложности и области применения:

- Простое поведение объектов (Прототипы)
- Обработка данных и JSON-шаблонов для IoT-соединений
- Настройка и работа с архивами

  Каждая из этих областей требует уникального подхода, который будет рассмотрен далее, начиная с простых сценариев и переходя к более сложным.

  # <a name="_heading=h.tyjcwt"></a>**2. Поведение прототипа: основные принципы и примеры скриптов**
  **Behavior** — это скрипт, выполняемый при изменении экземпляра прототипа (например, при создании, редактировании или удалении объекта). Скрипты для прототипов задают поведение объекта в системе и позволяют реализовать базовые автоматические действия.
  ## <a name="_heading=h.3dy6vkm"></a>**2.1 Базовая структура скрипта поведения**
  Простейший скрипт для поведения прототипа экспортирует три функции:

- **on\_create/1** — выполняется при создании экземпляра прототипа.
- **on\_edit/1** — выполняется при редактировании полей экземпляра прототипа.
- **on\_delete/1** — выполняется при удалении экземпляра прототипа.

  Образец скрипта:

  %%-------------------------------------------------------

  %% This script is executed at the server side. The programming language

  %% is Erlang.

  %% The module MUST export next 3 methods:

  %% \* on\_create/1 - this method is called when a new instance of the prototype is created.

  %% \* on\_edit/1 - this method is called when own fields of an instance of the prototype are edited

  %% \* on\_delete/1 - this method is called when an instance of the prototype is deleted

  %% All this methods accept an Object of the instance and can edit or perform any other allowed code.

  %% If any of the methods throw or crash the whole transaction will rollback.

  %% If there are any warnings or not critical errors it is recommended to log them with available macros, examples:

  %% ?LOGWARNING( "my warning text: ~p", [Warning] )

  %% ?LOGERROR( "my error text: ~p", [Error] )

  %% If the methods performs well it should return atom 'ok'.

  %% For more info please refer to the documentation

  %%-------------------------------------------------------

  -module(fp\_prototype\_MyProto1).

  -include("fp\_struct.hrl").

  -export([

  `    `on\_create/1,

  `    `on\_delete/1,

  `    `on\_edit/1

  ]).

  on\_create(\_Object)->

  `    `ok.

  on\_edit(\_Object)->

  `    `ok.

  on\_delete( Object )->

  `    `ok.

  Рассмотрим примеры создания скриптов, определяющих поведение прототипа на языке Erlang.

  **Пример 1:**

  %%-------------------------------------------------------

  %% This script is executed at the server side. The programming language

  %% is Erlang.

  %% The module MUST export next 3 methods:

  %% \* on\_create/1 - this method is called when a new instance of the prototype is created.

  %% \* on\_edit/1 - this method is called when own fields of an instance of the prototype are edited

  %% \* on\_delete/1 - this method is called when an instance of the prototype is deleted

  %% All these methods accept an Object of the instance and can edit or perform any other allowed code.

  %% If any of the methods throw or crash, the whole transaction will rollback.

  %% If there are any warnings or non-critical errors, it is recommended to log them with available macros, examples:

  %% ?LOGWARNING( "my warning text: ~p", [Warning] )

  %% ?LOGERROR( "my error text: ~p", [Error] )

  %% If the methods perform well, they should return the atom 'ok'.

  %% For more info, please refer to the documentation

  %%-------------------------------------------------------

  -module(fp\_prototype\_MyProto1).

  -include("fp\_struct.hrl").

  -export([

  `    `on\_create/1,

  `    `on\_delete/1,

  `    `on\_edit/1

  ]).

  on\_create(Object) ->

  `    `io:format("Instance of MyProto1 created: ~p~n", [Object]),

  `    `ok.

  on\_edit(Object) ->

  `    `io:format("Fields of MyProto1 instance edited: ~p~n", [Object]),

  `    `ok.

  on\_delete(Object) ->

  `    `io:format("Instance of MyProto1 deleted: ~p~n", [Object]),

  `    `ok.

  Этот скрипт реализует три метода: on\_create, on\_edit и on\_delete, которые вызываются при создании, изменении и удалении экземпляра прототипа соответственно. В данном примере эти методы просто выводят сообщение в консоль, указывая на то, что произошло с экземпляром. Вы можете дополнить их логикой, соответствующей вашим требованиям.

  **Пример 2:**

  Давайте расширим последний скрипт для работы с прототипом, представляющим конкретное устройство. Для примера давайте предположим, что у нас есть прототип устройства, представляющего насос, и мы хотим, чтобы наш скрипт выполнял определенные действия в зависимости от состояния этого насоса.

  %%-------------------------------------------------------

  %% This script is executed at the server side. The programming language

  %% is Erlang.

  %% The module MUST export next 3 methods:

  %% \* on\_create/1 - this method is called when a new instance of the prototype is created.

  %% \* on\_edit/1 - this method is called when own fields of an instance of the prototype are edited

  %% \* on\_delete/1 - this method is called when an instance of the prototype is deleted

  %% All these methods accept an Object of the instance and can edit or perform any other allowed code.

  %% If any of the methods throw or crash, the whole transaction will rollback.

  %% If there are any warnings or non-critical errors, it is recommended to log them with available macros, examples:

  %% ?LOGWARNING( "my warning text: ~p", [Warning] )

  %% ?LOGERROR( "my error text: ~p", [Error] )

  %% If the methods perform well, they should return the atom 'ok'.

  %% For more info, please refer to the documentation

  %%-------------------------------------------------------

  -module(fp\_prototype\_Pump).

  -include("fp\_struct.hrl").

  -export([

  `    `on\_create/1,

  `    `on\_delete/1,

  `    `on\_edit/1

  ]).

  -define(PUMP\_STATE\_NORMAL, 0).

  -define(PUMP\_STATE\_WARNING, 1).

  -define(PUMP\_STATE\_ERROR, 2).

  on\_create(Object) ->

  `    `io:format("Pump instance created: ~p~n", [Object]),

  `    `ok.

  on\_edit(Object) ->

  % Проверяем состояние насоса и выполняем соответствующие действия

  `    `case Object#pump.state of

  `        `?PUMP\_STATE\_NORMAL ->

  `            `io:format("Pump is in normal state: ~p~n", [Object]),

  `            `ok;

  `        `?PUMP\_STATE\_WARNING ->

  `            `io:format("Pump is in warning state: ~p~n", [Object]),

  `            `ok;

  `        `?PUMP\_STATE\_ERROR ->

  `            `io:format("Pump is in error state: ~p~n", [Object]),

  `            `ok

  end.

  on\_delete(Object) ->

  `    `io:format("Pump instance deleted: ~p~n", [Object]),

  `    `ok.

  Этот скрипт добавляет обработку состояния насоса в методе on\_edit. В зависимости от состояния насоса он выводит соответствующее сообщение в консоль. Вы можете дополнить скрипт логикой обработки состояний насоса, включая отправку уведомлений, запись в журнал или выполнение дополнительных действий.

  **Пример 3:**

  Прототипы в SCADA-системах часто имеют набор полей, которые определяют их свойства и характеристики. Для дать определение прототипа на основании этого, мы можем добавить определение полей в Erlang-модуль прототипа. Вот пример определения прототипа на основании всего выше перечисленного:

  %%--------------------------------------------------------

  %% This script is executed at the server side. The programming language

  %% is Erlang.

  %% The module MUST export next 3 methods:

  %% \* on\_create/1 - this method is called when a new instance of the prototype is created.

  %% \* on\_edit/1 - this method is called when own fields of an instance of the prototype are edited

  %% \* on\_delete/1 - this method is called when an instance of the prototype is deleted

  %% All these methods accept an Object of the instance and can edit or perform any other allowed code.

  %% If any of the methods throw or crash, the whole transaction will rollback.

  %% If there are any warnings or non-critical errors, it is recommended to log them with available macros, examples:

  %% ?LOGWARNING( "my warning text: ~p", [Warning] )

  %% ?LOGERROR( "my error text: ~p", [Error] )

  %% If the methods perform well, they should return the atom 'ok'.

  %% For more info, please refer to the documentation

  %%--------------------------------------------------------

  -module(fp\_prototype\_Pump).

  -include("fp\_struct.hrl").

  -export([

  `    `on\_create/1,

  `    `on\_delete/1,

  `    `on\_edit/1

  ]).

  -record(pump, {

  `    `id :: string(),

  `    `name :: string(),

  `    `type :: string(),

  `    `state :: integer()

  }).

  -define(PUMP\_STATE\_NORMAL, 0).

  -define(PUMP\_STATE\_WARNING, 1).

  -define(PUMP\_STATE\_ERROR, 2).

  on\_create(Object) ->

  `    `io:format("Pump instance created: ~p~n", [Object]),

  `    `ok.

  on\_edit(Object) ->

  % Проверяем состояние насоса и выполняем соответствующие действия

  `    `case Object#pump.state of

  `        `?PUMP\_STATE\_NORMAL ->

  `            `io:format("Pump is in normal state: ~p~n", [Object]),

  `            `ok;

  `        `?PUMP\_STATE\_WARNING ->

  `            `io:format("Pump is in warning state: ~p~n", [Object]),

  `            `ok;

  `        `?PUMP\_STATE\_ERROR ->

  `            `io:format("Pump is in error state: ~p~n", [Object]),

  `            `ok

  end.

  on\_delete(Object) ->

  `    `io:format("Pump instance deleted: ~p~n", [Object]),

  `    `ok.

  В этом примере добавлено определение полей прототипа pump, включая id, name, type и state. Для каждого поля указан тип данных. Теперь прототип насоса имеет определенную структуру данных, которая позволяет представлять его свойства и характеристики.

  # <a name="_heading=h.1t3h5sf"></a>**3. Обработка валидных JSON-данных для IoT-соединений**
  JSON-шаблоны играют ключевую роль в передаче данных между SCADA-системой и внешними системами в контексте IIoT. С помощью JSON-шаблонов можно получать данные с датчиков, отправлять команды управления и запросы на получение исторических данных.
  ## <a name="_heading=h.4d34og8"></a>**3.1 Json-шаблоны**
  JSON (JavaScript Object Notation) - это легкий формат обмена данными, который широко используется для передачи структурированной информации между приложениями. В контексте IIoT-платформы, JSON-шаблоны играют ключевую роль в обмене данными с внешними системами. Вот как их создавать, использовать и примеры их применения:

  *Создание JSON-шаблонов:*

  • Определите структуру данных: Прежде всего, определите, какие данные вы хотите передавать или получать. Разбейте их на логические блоки или объекты.

  • Определите ключи и значения: Для каждого блока данных определите ключи и соответствующие значения. Ключи представляют собой названия атрибутов, а значения - сами данные.

  • Следуйте синтаксису JSON: Убедитесь, что ваш JSON-шаблон соответствует синтаксису JSON. Он должен состоять из пар "ключ: значение", разделенных запятыми, и ограниченных фигурными скобками для объектов.

  *Использование JSON-шаблонов:*

  • Прием данных: Для приема данных из внешних систем, IIoT-платформа считывает JSON-шаблон, а затем обрабатывает полученные данные в соответствии с вашей логикой (скриптом).

  • Отправка данных: Для отправки данных во внешние системы, сначала сформируйте JSON-шаблон в соответствии с требованиями внешней системы, затем отправьте его через соответствующий канал связи.

  *Использование различных структур данных в JSON-шаблонах.*

  Синтаксис JSON-шаблонов для IIoT-платформ может быть таким же, как и для обычных JSON-данных.

  В качестве значений в JSON-шаблонах могут передаваться как простые типы данных (переменные), так и массивы, и другие более сложные типы.

  Примеры типов данных, которые могут быть использованы в JSON-шаблонах IIoT-платформ:

  a) Массивы (Arrays):

  {

  `   `"sensorData": {

  `      `"temperatures": [25.5, 26.1, 24.8],

  `      `"humidities": [60, 62, 58]

  `   `}

  }

  b) Объекты (Objects):

  {

  `   `"sensorData": {

  `      `"location": {

  `         `"latitude": 40.7128,

  `         `"longitude": -74.0060

  `      `}

  `   `}

  }

  c) Строки (Strings), Числа (Numbers), Логические значения (Boolean):

  {

  `   `"equipmentStatus": {

  `      `"pump1": true,

  `      `"pump2": false,

  `      `"errorCode": 123,

  `      `"message": "Pump overheating"

  `   `}

  }

  d) Null-значения (Null):

  {

  `   `"configuration": {

  `      `"timeout": null

  `   `}

  }

  e) Вложенные структуры (Nested Structures):

  {

  `   `"productionData": {

  `      `"line1": {

  `         `"output": 500,

  `         `"defects": ["Scratch", "Crack"]

  `      `},

  `      `"line2": {

  `         `"output": 600,

  `         `"defects": ["Chip"]

  `      `}

  `   `}

  }

  *Примеры использования JSON-шаблонов:*

  a) Пример JSON-данных для передачи данных о температуре и влажности с датчиков в IIoT-платформу:

  {

  `   `"sensorData": {

  `      `"temperature": 25.5,

  `      `"humidity": 60

  `   `}

  }

  b) Пример JSON-данных для управления устройством через IIoT-платформу:

  {

  `   `"deviceControl": {

  `      `"deviceId": "123456",

  `      `"command": "on"

  `   `}

  }

  c) Пример JSON-данных для получения данных о состоянии оборудования из IIoT-платформы:

  {

  `   `"equipmentStatus": {

  `      `"pump1": "running",

  `      `"pump2": "stopped"

  `   `}

  }

  d) Пример JSON-данных для передачи данных о производственных параметрах:

  {

  `   `"productionData": {

  `      `"machineId": "123",

  `      `"temperature": 180,

  `      `"pressure": 45,

  `      `"output": 500

  `   `}

  }

  e) Пример JSON-данных для управления режимами работы оборудования:

  {

  `   `"equipmentControl": {

  `      `"deviceId": "789",

  `      `"mode": "manual",

  `      `"settings": {

  `         `"speed": 50,

  `         `"temperatureSetpoint": 200

  `      `}

  `   `}

  }

  f) Пример JSON-данных для передачи событий и аварий:

  {

  `   `"alarmData": {

  `      `"alarmId": "ABC123",

  `      `"severity": "high",

  `      `"description": "Critical temperature threshold exceeded",

  `      `"timestamp": "2024-05-02T10:30:00"

  `   `}

  }

  g) Пример JSON-данных для запроса исторических данных:

  {

  `   `"historicalDataRequest": {

  `      `"startDate": "2024-04-01",

  `      `"endDate": "2024-04-30",

  `      `"parameters": ["temperature", "pressure", "output"]

  `   `}

  }

  h) Пример JSON-данных для передачи информации о системных настройках:

  {

  `   `"systemSettings": {

  `      `"samplingRate": 1000,

  `      `"language": "en",

  `      `"timezone": "UTC+3"

  `   `}

  }
  ###
  # <a name="_heading=h.2s8eyo1"></a>**4. Использование скриптов для обработки поступивших Json-данных**
  *Скрипт Erlang для обработки JSON-данных:*

  -module(json\_handler).

  -export([process\_json/1]).

  % Функция для обработки JSON-данных

  process\_json(JsonData) ->

  % Парсим JSON

  {ok, Json} = jsx:decode(JsonData),

  `	  `% Выполняем операции в зависимости от типа данных

  `	  `case proplists:get\_value(<<"sensorData">>, Json) of

  `	  	`undefined ->

  `	  		`io:format("Unknown JSON data: ~p~n", [Json]);

  `	  	 `SensorData ->

  `	  		`% Обрабатываем данные о датчиках

  `	  		`process\_sensor\_data(SensorData)

  `	  `end.

  % Функция для обработки данных о датчиках

  process\_sensor\_data(SensorData) ->

  Temperature = proplists:get\_value(<<"temperature">>, SensorData),

  Humidity = proplists:get\_value(<<"humidity">>, SensorData),

  io:format("Received sensor data - Temperature: ~p, Humidity: ~p~n", [Temperature, Humidity]).

  *Скрипт JavaScript для обработки JSON-данных:*

  // Функция для обработки JSON-данных

  function processJson(jsonData) {

  `   `// Разбираем ("парсим") JSON

  `   `const json = JSON.parse(jsonData);

  `   `// Выполняем операции в зависимости от типа данных

  `   `if (json.sensorData) {

  `      `// Обрабатываем данные о датчиках

  `      `processSensorData(json.sensorData);

  `   `} else {

  `      `console.log("Unknown JSON data:", json);

  `   `}

  }

  // Функция для обработки данных о датчиках

  function processSensorData(sensorData) {

  `   `const temperature = sensorData.temperature;

  `   `const humidity = sensorData.humidity;

  `   `console.log(`Received sensor data - Temperature: ${temperature}, Humidity: ${humidity}`);

  }

  # <a name="_heading=h.17dp8vu"></a>**5. Создание и настройка архивов**
  Архивы предназначены для долгосрочного хранения данных в SCADA-системе. В каждом архиве можно задавать параметры, такие как периодичность записи, источник данных и глубина хранения.

  Одним из основных элементов для создания архива является привязка, которую можно определить с помощью скрипта, что позволяет выполнять дополнительную обработку архивируемого значения (например, вычисление среднего по нескольким точкам измерения) и вычислять значения архива по нескольким входным параметрам (например, сумма показаний нескольких расходомеров); возвращаемые из скрипта значения, сохраняются в базе архивов.

  **Пример** скрипта для обработки данных в архиве:

  Сначала следует выбрать один из двух языков программирования скрипта - Erlang или Javascript. Затем ввести переменную и выбрать источник значений показателя для скрипта.

  ![Aspose words 7e55d7ce c0e4 4a18 9a16 39bde3184163 001](Aspose.Words.9ae2a643-68c3-4dd2-91ef-5048a0c23abe.003.png)

  **Пример** скрипта для вычисления скользящего среднего по последним 10 значениям для Erlang:

  %% Script must be an Erlang fun of arity 2.

  %% - VARS argument is a map that contains

  %%   values for the defined variables.

  %%   Key - variable name, Value - variable value

  %% - State is an argument that can be used as an accumulator.

  %%   It keeps the value of the accumulator that was returned

  %%   from the previous call

  %% The function must return a tuple:

  %%   { <value>, <accumulator> }

  %%

  fun(VARS,\_State)->

  `    `% Extract the current value from VARS

  `    `CurrentValue = maps:get("var\_1", VARS, 0),



`    `% Initialize or update the list of last 10 values

`    `ValuesList = case State of

`        `undefined ->

`            `[CurrentValue];  % Initialize the state if it is undefined

`        `\_ when is\_list(State) ->

`            `[CurrentValue | State]  % Add the new value to the list

`    `end,

`    `% Keep only the last 10 values

`    `TrimmedList = lists:sublist(ValuesList, min(length(ValuesList), 10)),

`    `% Calculate the moving average

`    `Avg = case TrimmedList of

`        `[] ->

`            `0;  % Avoid division by zero

`        `\_ ->

`            `lists:sum(TrimmedList) / length(TrimmedList)

`    `end,

`    `% Return the calculated average and updated state

`    `{Avg, TrimmedList}

end.

**Пример** скрипта для вычисления скользящего среднего по последним 10 значениям для Javascript:

// Script must be an Javascript fun of arity 2.

// - VARS argument is a map that contains

//   values for the defined variables.

//   Key - variable name, Value - variable value

// - State is an argument that can be used as an accumulator.

//   It keeps the value of the accumulator that was returned

//   from the previous call

// The function must return an object:

//   { value:<value>, state:<accumulator> }

//

async function(VARS, State) {

`    `// Extract the current value from VARS

`    `let currentValue = VARS.var\_1 || 0; // Default to 0 if var\_1 is undefined

`    `// Initialize or update the list of the last 10 values

`    `let valuesList = Array.isArray(State) ? State : []; // Ensure State is an array

`    `valuesList = [currentValue, ...valuesList]; // Add the current value to the beginning

`    `// Keep only the last 10 values

`    `if (valuesList.length > 10) {

`        `valuesList = valuesList.slice(0, 10);

`    `}

`    `// Calculate the moving average

`    `let avg = valuesList.reduce((sum, val) => sum + val, 0) / valuesList.length;

`    `// Return the calculated average and updated state

`    `return { value: avg, state: valuesList };

}

Для компиляции скрипта необходимо нажать кнопку ![Aspose words 7e55d7ce c0e4 4a18 9a16 39bde3184163 004](Aspose.Words.9ae2a643-68c3-4dd2-91ef-5048a0c23abe.004.png)

Если компиляция выполнена без ошибок, то напротив кнопки компиляции появится надпись “ok”, иначе будет выведен список ошибок, например:

![Aspose words 7e55d7ce c0e4 4a18 9a16 39bde3184163 005](Aspose.Words.9ae2a643-68c3-4dd2-91ef-5048a0c23abe.005.png)

**Общий принцип работы:**

- Система архивирования считывает значения из полей тегов, к которым привязаны объявленные переменные.
- Выполняется вызов скрипта с передачей на вход map со значениями переменных.
- Сохранение в базу архивов значений переменных, возвращаемых из скрипта.
  # <a name="_heading=h.5f7t4lroh6ow"></a>**6. Интеграция с Power Factory (fp\_powerfactory\_service)**
  Взаимодействие между Faceplate и PowerFactory организовано через промежуточный сервис **server.py**, который предоставляет необходимый Json API. Передача данных между Faceplate и **server.py** осуществляется с использованием протокола HTTP.

  Модуль интеграции в Faceplate выполняет следующие задачи:

- формирование и отправка json-данных в сервис **server.py**;
- обработка результатов запросов;
- сохранение полученных данных в базу Faceplate.

Сервис server.py определяет следующие api-функции:

`     	`create

`     	`check

`     	`execute

`     	`dynamics

`     	`get\_links

`     	`get\_type\_library

`     	`get

`     	`update

`     	`weightings.

Для каждой из этих функций предусмотрен соответствующий Json-шаблон, обеспечивающий стандартизацию запросов и их обработки.

В общем виде, формат отправляемого json:

{

`     	`"project\_params": {

`               	`"project\_name": project\_name,

`        `"study\_case\_name": study\_case\_name,

`        `"operation\_scenario\_name": operation\_scenario\_name,

`               	`"grid\_name": grid\_name,

`        `"func\_name": func\_name,

`               	`"id": user\_id

`               	`"session\_type": session\_type

`     	`},

`    `pf\_element\_1\_typename: pf\_element\_1\_params

`    `pf\_element\_2\_typename: pf\_element\_2\_params

...

`    `pf\_element\_N\_typename: pf\_element\_N\_params

}



Объект project\_params содержит параметры проекта PowerFactory, для которого выполняется запрос, а также название выполняемой функции.

Поля pf\_element\_1\_typename, pf\_element\_2\_typename, pf\_element\_N\_typename соответствуют названиям типов элементов в PowerFactory, используемых для расчетов, либо для загрузки/выгрузки данных в PowerFactory.

В объектах pf\_element\_1\_params, pf\_element\_2\_params, pf\_element\_N\_params находятся данные самих объектов соответствующих типов, необходимые для соответствующей функции.

Например:

` `"ElmTr3": {

`    `"Grid\\KAZ\\ZAPAD\\Kulsary/220/AT2": {

`      `"links": {

`        `"busmv": "none",

`        `"buslv": "Grid\\KAZ\\ZAPAD\\Kulsary/110/AT2 term",

`        `"bushv": "Grid\\KAZ\\ZAPAD\\Kulsary/220/AT2/term"

`      `}

`    `},

`    `"Grid\\KAZ\\ALMATY\\SHU/220/AT1": {

`      `"links": {

`        `"busmv": "none",

`        `"buslv": "Grid\\KAZ\\ALMATY\\SHU/110/AT1 term",

`        `"bushv": "Grid\\KAZ\\ALMATY\\SHU/220/AT1/term"

`      `}

`    `},
## <a name="_heading=h.9pyppdhusbfs"></a>**6.1 Файл настроек**
Для формирования соответствующего json, на стороне fp\_powerfactory\_service (см. Приложение А.8) используется файл настроек, находящийся в приватной директории модуля:

../lib/fp\_powerfactory\_service/priv/fp2pf\_mapping.json.

В данном файле определяются функции, типы объектов powerfactory, с которыми работают функции и маппинг полей прототипов faceplate на атрибуты соответствующих классов объектов в PowerFactory:

\1) Маппинг полей прототипов faceplate на атрибуты соответствующих классов объектов в PowerFactory определяется в разделе "\_elements" настроечного файла\.

Пример:

"ElmLne": {

`     	`"\_prototype": "line",

`    `"$path": {

`               	`"pf\_attr": {

`          `"\_field": "pf\_attr"

`        `},

`        `"params": {

`          `"outserv": {

`        	`"\_field": "pf\_outserv"

`          `}

`        `},

`        `"links": {

`          `"bus1": {

`        	`"\_field": "pole\_i"

`          `},

`          `"bus2": {

`        	`"\_field": "pole\_j"

`          `}

`        `},

`        `"results": {

`          `"m:P:bus1": {

`        	`"\_field": "pf\_m\_P\_bus1"

`          `},

`          `"m:P:bus2": {

`        	`"\_field": "pf\_m\_P\_bus2"

`          `},

`          `"m:Q:bus1": {

`        	`"\_field": "pf\_m\_Q\_bus1"

`          `},

`          `"m:Q:bus2": {

`        	`"\_field": "pf\_m\_Q\_bus2"

`          `},

`          `"c:loading": {

`        	`"\_field": "pf\_c\_loading"

`          `}

`       `}

`     	`}

}

....



Представленный выше фрагмент настроечного json-файла определяет структуру json и позволяет получить json вида:

"ElmLne": {

`    `"Grid\\KAZ\\CENTER\\@lines/L2378/lineB": {

`               	`"pf\_attr": null

`        `"params": {

`          `"outserv": null

`        `},

`        `"links": {

`          `"bus1": "Grid\\KAZ\\CENTER\\Karajal\\220/L2378",

`          `"bus2": "Grid\\KAZ\\CENTER\\Jezkaz\_TEC\\220/L2378"

`        `},

`        `"results": {

`          `"m:P:bus1": null,

`          `"m:P:bus2": null,

`          `"m:Q:bus1": null

`          `"m:Q:bus2": null

`          `"c:loading": null

`       `}

`     	`}

}

Поля с префиксом \_ в файле настроек являются служебными и не включаются в результирующую структуру json.

Поле "\_prototype" в файле настроек определяет прототип faceplate, соответствующий вышестоящему элементу.

Поле "\_field" в файле настроек, определяет поле прототипа faceplate, значение которого для соответствующего объекта будет записано в результирующий json.

Если значение необходимо получить не из самого объекта прототипа, а из вложенного объекта - на одном уровне с служебным полем "\_field" следует добавить служебное поле "\_path", значение которого должно содержать относительный путь до вложенного объекта.

Поле "$path" в файле настроек, в результирующей структуре заменяется на путь к соответствующему объекту.

Для некоторых типов объектов PowerFactory в настроечном файле может быть не указано поле "$path", например:

"ComLdf": {

`     	`"\_prototype": "PowerFactory\_ComLdf",

`     	`"params": {

`     	`"\_field": "params"

`    `},

`    `"status": {

`        `"\_field": "status"

`    `}

},

В таком случае, при вызове функции запроса в PowerFactory необходимо указывать OID объекта прототипа (в данном случае, PowerFactory\_ComLdf), данные которого нужно передать (см. Приложение А.8).

Если требуется сформировать json из данных каталога faceplate, то в файле настроек вместо служебного поля "\_prototype", нужно использовать поле "\_catalog", указав имя каталога, например:

"TypLne": {

`     	`"\_catalog": "equipment\_types\\TypLne",

`    `"$path": {

`     	`"params": {

`               	`"name": {

`        	   	`"\_field": ".name"

`               	`},

`               	`"json": {

`        	   	`"\_field": "json"

`               	`}

`        `}

`     	`}

}

\2) Определение функций

Функции определяются в разделе "\_functions" настроечного файла.

Пример:

` `"get\_in": {

`     	`"elements": ["ElmSite", "ElmSubstat", "ElmTerm", "ElmCoup", "ElmTr2", "ElmTr3", "ElmGenstat", "ElmSym", "ElmLod", "ElmShnt", "ElmBranch", "ElmLne", "ElmLnesec", "ElmXnet"],

`     	`"json\_fields": {"$path": ["parms"]}

},

"get\_out": {

`     	`"elements": ["ElmSite", "ElmSubstat", "ElmTerm", "ElmCoup", "ElmTr2", "ElmTr3", "ElmGenstat", "ElmSym", "ElmLod", "ElmShnt", "ElmBranch", "ElmLne", "ElmLnesec", "ElmXnet"],

`     	`"json\_fields": {"$path":  ["results"]}

` `}

В данном примере определяется функция get.

"get\_in" определяет элементы и поля (заданные в разделе маппинга), которые будут использоваться при формировании json, отправляемого в PowerFactory. В данном случае, json отправляемый в PowerFactory, будет содержать в элементах только поле "params", и не будет включать другие поля ("pf\_attr", "links", "results"), определенные в разделе маппинга.

"get\_out" определяет элементы и поля (заданные в разделе маппинга), которые будут загружаться из полученного от PowerFactory json в базу данных faceplate. В данном случае, загружаться будут только данные из раздела "results".



\3) Преобразование путей Faceplate и PowerFactory

Путь к объекту Faceplate, как и путь к объекту в PowerFactory, однозначно определяет объект.

В faceplate и PowerFactory пути к объектам отличаются. Например путь к объекту трансформатора c именем AT2 в faceplate может быть таким:

'/root/FP/PROJECT/KAZ/ZAPAD/Kulsary/220/AT2'. Данному объекту соответствует объект в PowerFactory, у которого путь: 'Grid\\KAZ\\ZAPAD\\Kulsary\\220/AT2'.

Причем имя объекта в PowerFactory '220/AT2', а часть пути 'Grid\\KAZ\\ZAPAD\\Kulsary' определяет иерархию директорий (папок) для этого объекта. В данном случае, часть пути '/root/FP/PROJECT' соответствует 'Grid' в PowerFactory.

Соответствие между путем faceplate и путем PowerFactory определяется в разделе "pf\_path\_mapping". Данное соответствие используется при выгрузке данных из faceplate в PowerFactory/

Пример:

"pf\_path\_mapping": {

`    `"^/root/FP/PROJECT": ["Grid", 4],

`    `"^/root/FP/catalogs/equipment\_types([\\w\\W]\*)/content": ["Equipment Type Library", 1]

` `},

В левой части определено регулярное выражение ("^/root/FP/PROJECT"), которое соответствует части пути в faceplate, которое будет заменено на значение первого элемента списка, находящегося в правой части. Второй элемент данного списка является целым числом, которое определяет глубину пути к объекту в PowerFactory. Т.е. 'Grid\\KAZ\\ZAPAD\\Kulsary' имеет глубину 4. Оставшаяся часть пути будет преобразована в имя объекта '220/AT2'.

В приведенном примере аналогичным образом определено соответствие между путем к элементу каталога 'equipment\_types' в базе faceplate и путем к объекту в библиотеке типов оборудования в PowerFactory.

` `Обратное преобразование путей используется для загрузки данных из PowerFactory в faceplate. Оно определено в разделе "fp\_path\_mapping".

Пример:

"fp\_path\_mapping": {

`    `"^Grid": "/root/FP/PROJECT",

`    `"^Equipment Type Library": "/root/FP/catalogs/equipment\_types\\\\${element\_type}/content",

}

В левой части определено регулярное выражение, которое соответствует части пути в faceplate, которое будет заменено на значение в правой части.

В правой части может использоваться переменная ${element\_type}. В этой переменной передается PowerFactory класс  обрабатываемого объекта (например, 'TypLne'). В приведенном примере эта переменная используется определения имени каталога. В приведенном примере, результирующее имя каталога будет 'equipment\_types\TypLne' (в случае если обрабатываемый PowerFactory объект имеет тип 'TypLne').
## <a name="_heading=h.5jrucrh0atzh"></a>**6.2 Использование в прикладном проекте**
Несколько последовательных вызовов функции pf\_service\_update или pf\_service\_create\_update в прикладном проекте выполняются последовательно, т.е. пока не выполнится цикл отправки/получения данных для первого вызова функции, для второго вызова цикла отправки/получения данных не начнется.

В прикладном проекте создана пользовательская библиотека fp\_pf\_utils, облегчающая использование модуля в прикладных скриптах.

-module(fp\_pf\_utils).

%%---------------------------------------



-include("fp.hrl").



-export([

`    `pf\_get/0,

`    `pf\_execute/0,

`    `pf\_dynamics/0,

`    `pf\_update/0,

`    `pf\_reset\_calc/0

`  `]).



-define(HOST, "10.210.1.25").

-define(PORT, 80).



-define(PROJECTNAME, <<".MODEL\_SCADA\_V1115">>).

-define(SCENARIO, <<"scenario\_dynamics">>).



pf\_get() ->

`  `ProjectParams = #{

`    `<<"func\_name">> => <<"get">>,

`    `<<"grid\_name">> => <<"Grid">>,

`    `<<"project\_name">> => ?PROJECTNAME,

`    `<<"study\_case\_name">> => <<"Study Case">>,

`    `<<"operation\_scenario\_name">> => ?SCENARIO,

`    `<<"session\_type">> => <<"calculation">>,

`    `<<"id">> => <<"abcd-1234">>

`  `},

`  `fp\_powerfactory\_service:pf\_service\_update(ProjectParams, none, ?HOST, ?PORT).



pf\_update() ->

`  `ProjectParams = #{

`    `<<"func\_name">> => <<"update">>,

`    `<<"grid\_name">> => <<"Grid">>,

`    `<<"project\_name">> => ?PROJECTNAME,

`    `<<"study\_case\_name">> => <<"Study Case">>,

`    `<<"operation\_scenario\_name">> => ?SCENARIO,

`    `<<"session\_type">> => <<"calculation">>,

`    `<<"id">> => <<"abcd-1234">>

`  `},

`  `fp\_powerfactory\_service:pf\_service\_update(ProjectParams, none, ?HOST, ?PORT).



pf\_execute() ->

`  `ProjectParams = #{

`    `<<"func\_name">> => <<"execute">>,

`    `<<"grid\_name">> => <<"Grid">>,

`    `<<"project\_name">> => ?PROJECTNAME,

`    `<<"study\_case\_name">> => <<"Study Case">>,

`    `<<"operation\_scenario\_name">> => ?SCENARIO,

`    `<<"session\_type">> => <<"calculation">>,

`    `<<"id">> => <<"abcd-1234">>

`  `},

`  `ComLdfOID = ?OID(<<"/root/FP/PROJECT/\_GRIDS/forPF/PF\_ComLDF">>),

`  `fp\_powerfactory\_service:pf\_service\_update(ProjectParams, [ComLdfOID], ?HOST, ?PORT).



pf\_dynamics() ->

`  `ProjectParams = #{

`    `<<"func\_name">> => <<"dynamics">>,

`    `<<"grid\_name">> => <<"Grid">>,

`    `<<"project\_name">> => ?PROJECTNAME,

`    `<<"study\_case\_name">> => <<"Study Case">>,

`    `<<"operation\_scenario\_name">> => ?SCENARIO,

`    `<<"session\_type">> => <<"calculation">>,

`    `<<"id">> => <<"abcd-1234">>

`  `},

`  `ComSimOID = ?OID(<<"/root/FP/PROJECT/\_GRIDS/forPF/PF\_ComSim">>),

`  `fp\_powerfactory\_service:pf\_service\_update(ProjectParams, [ComSimOID], ?HOST, ?PORT).



pf\_reset\_calc() ->

`	`ProjectParams = #{

`    `<<"func\_name">> => <<"reset\_calc">>,

`    `<<"grid\_name">> => <<"Grid">>,

`    `<<"project\_name">> => ?PROJECTNAME,

`    `<<"study\_case\_name">> => <<"Study Case">>,

`    `<<"operation\_scenario\_name">> => ?SCENARIO,

`    `<<"session\_type">> => <<"calculation">>,

`    `<<"id">> => <<"abcd-1234">>

`  `},

`  `fp\_powerfactory\_service:pf\_service\_update(ProjectParams, none, ?HOST, ?PORT).



Пример использования пользовательской библиотеки fp\_pf\_utils в пользовательском скрипте, для организации циклического взаимодействия между Faceplate и PowerFactory:

` `fun(VARS,\_State)->

`    `StatusObject = fp\_db:open(fp\_db:to\_oid(list\_to\_binary("/root/FP/PROJECT/@DTS/scripts/status"))),

`    `fp\_db:edit\_object(StatusObject, #{<<"value\_int">> => 2}),



`    `While = fun Loop(Status) ->

`        `if

`        	`Status == 2 ->

`            	`fp\_pf\_utils:pf\_dynamics(),

`            	`fp\_pf\_utils:pf\_get(),

`            	`{\_, StatusNew} = fp\_db:read\_field(StatusObject, <<"value\_int">>),

`            	`Loop(StatusNew);

`        	`true ->

`            	`fp:log(info, "Dynamics stopped, status ~p", [Status])

`        `end

`    `end,



`    `While(2),



`    `{ none, none }

end.

В данном скрипте циклично вызываются функции fp\_pf\_utils:pf\_dynamics() и fp\_pf\_utils:pf\_get(), пока значение поля "value\_int", объекта "/root/FP/PROJECT/@DTS/scripts/status" равно 2. Для остановки цикла передачи, внешний скрипт должен изменить значение этого поля на другое.
# <a name="_heading=h.3rdcrjn"></a>**7. Заключение**
Настоящее руководство описывает основные скрипты и функции в библиотеке Faceplate, которые позволяют программистам управлять данными, взаимодействовать с API, выполнять вычисления и автоматизировать процессы в SCADA-системе.
*Изм*

*Лист*

*№ докум*

*Подп.*

*Дата*

*Лист*

` `*PAGE 2*

*Инв. №подл.*

*Подп. и дата*

*Взам. инв. №*

*Инв. № дубл.*

*Подп. и дата*
![](Aspose.Words.9ae2a643-68c3-4dd2-91ef-5048a0c23abe.006.png)![](Aspose.Words.9ae2a643-68c3-4dd2-91ef-5048a0c23abe.007.png)![ref2]![ref2]![ref2]![ref2]![ref2]![ref2]![ref3]![ref3]![ref3]![ref4]![](Aspose.Words.9ae2a643-68c3-4dd2-91ef-5048a0c23abe.011.png)![](Aspose.Words.9ae2a643-68c3-4dd2-91ef-5048a0c23abe.012.png)![](Aspose.Words.9ae2a643-68c3-4dd2-91ef-5048a0c23abe.013.png)![ref4]![](Aspose.Words.9ae2a643-68c3-4dd2-91ef-5048a0c23abe.014.png)![](Aspose.Words.9ae2a643-68c3-4dd2-91ef-5048a0c23abe.015.png)![](Aspose.Words.9ae2a643-68c3-4dd2-91ef-5048a0c23abe.016.png)![](Aspose.Words.9ae2a643-68c3-4dd2-91ef-5048a0c23abe.017.png)![](Aspose.Words.9ae2a643-68c3-4dd2-91ef-5048a0c23abe.018.png)![](Aspose.Words.9ae2a643-68c3-4dd2-91ef-5048a0c23abe.019.png)
# <a name="_heading=h.26in1rg"></a>**Приложение А. Библиотечные скрипты и их функции**
В разделе "Библиотечные модули" представлено множество скриптов, каждый из которых реализует определенную функциональность для работы SCADA-системы Faceplate. Эти модули предоставляют программистам гибкие инструменты для автоматизации, анализа данных и интеграции с внешними сервисами.

Ниже приведен перечень доступных библиотечных модулей с пояснениями:
## <a name="_heading=h.lnxbz9"></a>**А.1 Модуль system\_utils (v1)**
Модуль с набором вспомогательных функций, предназначенных для поиска и обработки системных объектов. Применяется для оптимизации работы с объектами в системе.

**Общая информация**

Модуль system\_utils предоставляет функции для управления объектами системы и обработки данных. Код написан на языке программирования Erlang. Если функция выбрасывает исключение или происходит сбой, транзакция будет отменена. При успешном выполнении функции возвращают атом ok. Для логирования рекомендуется использовать макросы:

- ?LOGINFO( "my info text: ~p", [Info] )
- ?LOGWARNING( "my warning text: ~p", [Warning] )
- ?LOGERROR( "my error text: ~p", [Error] )

|**Функция**|**Описание**|
| :-: | :-: |
|find\_by\_pattern/2|<p>: Ищет объекты в хранилище данных, соответствующие заданному шаблону.</p><p>**Параметры**:</p><p>- Root (binary): Корневой путь проекта.</p><p>- Pattern (binary): Шаблон для поиска.</p><p>&emsp;**Возвращает**: Список путей к объектам.</p><p>&emsp;**Пример использования**:</p><p>&emsp;system\_utils:find\_by\_pattern(<<"KAZ/UZHNIY">>, <<"/root/FP/prototypes/telemetry/fields">>).</p><p>&emsp;</p>|
|csv\_to\_archive/2|<p>: Загружает данные из CSV-файла и сохраняет их в архив.</p><p>**Параметры**:</p><p>- Archive (binary): Архив для сохранения данных.</p><p>- CSVFile (binary): Путь к CSV-файлу.</p><p>&emsp;**Возвращает**: Атом ok в случае успеха или {error, Reason} в случае ошибки.</p><p>&emsp;**Пример использования**:</p><p>&emsp;system\_utils:csv\_to\_archive(<<"my\_archive">>, <<"/path/to/file.csv">>).</p>|
|vclass\_from\_object/1|<p>: Определяет класс объекта по его пути.</p><p>**Параметры**:</p><p>- Object (binary): Объект, для которого необходимо определить класс.</p><p>&emsp;**Возвращает**: Целое число, представляющее класс объекта, или 0, если совпадение не найдено.</p><p>&emsp;**Пример использования**:</p><p>&emsp;system\_utils:vclass\_from\_object(Object).</p><p>&emsp;</p>|
|utc\_time/0|<p>: Возвращает текущие дату и время в формате UTC.</p><p>**Параметры**: Нет.</p><p>**Возвращает**: Строку с отформатированной датой и временем.</p><p>**Пример использования**:</p><p>system\_utils:utc\_time().</p><p></p>|
|create\_csv/2|<p>: Создает CSV-файл с данными, извлеченными из хранилища данных.</p><p>**Параметры**:</p><p>- Path (binary): Путь для выборки данных.</p><p>- File (binary): Имя файла для сохранения.</p><p>&emsp;**Возвращает**: Атом ok в случае успеха.</p><p>&emsp;**Пример использования**:</p><p>&emsp;system\_utils:create\_csv(<<"/data/path">>, <<"output.csv">>).</p>|
|delete\_elements/4|<p>: Удаляет элементы из хранилища данных, соответствующие заданным критериям.</p><p>**Параметры**:</p><p>- Root (binary): Корневой путь проекта.</p><p>- Folder (binary): Папка для выборки.</p><p>- Pattern (binary): Шаблон для поиска.</p><p>- Name (binary): Имя элемента для удаления.</p><p>&emsp;**Возвращает**: Атом ok в случае успеха.</p><p>&emsp;**Пример использования**:</p><p>&emsp;system\_utils:delete\_elements(<<"UZHNIY">>, <<"@models">>, <<"/root/FP/prototypes/telemetry/fields">>, <<"Uac">>).</p><p>&emsp;</p>|
|set\_state\_value/4|<p>: Устанавливает значение полей объектов state, вложенных в объекты, соответствующие заданным прототипам и находящиеся в заданном контексте.</p><p>**Параметры**:</p><p>- Context (binary): Контекст, в котором будет установлено значение.</p><p>- EdgePrototypes (list): Список прототипов.</p><p>- Path (binary): Относительный путь к объекту состояния</p><p>- FieldMap (map): Карта полей для обновления.</p><p>&emsp;**Возвращает**: Атом ok в случае успеха.</p><p>&emsp;**Пример использования**:</p><p>&emsp;system\_utils:set\_state\_value(<<"/root/FP/PROJECT/KAZ/UZHNIY/Kyzylorda">>, [<<"isolator">>, <<"earth\_isolator">>], <<"/state">>, #{<<"in\_value">> => 1}).</p><p>&emsp;</p>|

## <a name="_heading=h.35nkun2"></a>**А.2 Модуль weather\_service**
Служба интеграции прогноза погоды. Этот модуль взаимодействует с внешним API для получения данных о погоде, которые могут использоваться для анализа и прогноза производительности системы, учитывая метеоусловия.

**Общая информация**

Модуль weather\_service предназначен для получения информации о текущей погоде и прогноза на 24 часа. Модуль разработан на языке Erlang. Для логирования сообщений предлагается использовать макросы: ?LOGINFO, ?LOGWARNING, ?LOGERROR и обеспечивать откат транзакций при ошибках. При успешном оформлении возвращается атом ok.

|**Функция**|**Описание**|
| :-: | :-: |
|forecast24/1|<p>: Получает прогноз погоды на 24 часа через API OpenWeatherMap.</p><p>**Параметры**:</p><p>- Obj (map): Объект, содержащий координаты (широта lat и долгота lon).</p><p>&emsp;**Возвращает**: Обработанные данные о прогнозе, включая массивы температуры, давления, влажности, скорости и направления ветра.</p><p>&emsp;**Пример использования**:</p><p>&emsp;weather\_service:forecast24(Object).</p><p>&emsp;**Детали реализации**:</p><p>- Чтение координат из объекта с использованием fp\_db:read\_fields.</p><p>- Формирование URL для запроса к API.</p><p>- Выполнение HTTP-запроса с использованием модуля httpc.</p><p>- Парсинг ответа JSON с помощью библиотеки jsx.</p><p>- Обработка данных прогноза для температуры, давления, влажности, скорости и направления ветра.</p>|
|current/1|<p>: Получает текущую погоду через API OpenWeatherMap.</p><p>**Параметры**:</p><p>- Obj (map): Объект, содержащий координаты (широта lat и долгота lon).</p><p>&emsp;**Возвращает**: Карта значений с текущими погодными данными:</p><p>- ts: Временная метка.</p><p>- pressure: Давление (гПа).</p><p>- temperature: Температура (°C).</p><p>- humidity: Влажность (%).</p><p>- wind\_speed: Скорость ветра (м/с).</p><p>- wind\_direction: Направление ветра (градусы).</p><p>&emsp;**Пример использования**:</p><p>&emsp;weather\_service:current(Object).</p><p>&emsp;**Детали реализации**:</p><p>- Чтение координат из объекта с использованием fp\_db:read\_fields.</p><p>- Формирование URL для запроса к API.</p><p>- Выполнение HTTP-запроса с использованием модуля httpc.</p><p>- Парсинг ответа JSON с помощью библиотеки jsx.</p><p>- Извлечение значений давления, температуры, влажности, скорости и направления ветра.</p><p>&emsp;</p>|

**Примечания**

- Убедитесь, что у вас есть действительный ключ API OpenWeatherMap.
- Для повышения производительности рекомендуется кешировать результаты запросов.

  ## <a name="_heading=h.1ksv4uv"></a>**А.3 Модуль fp\_userlib\_archive**
  Модуль для работы с архивами. Предназначен для управления архивированием данных и взаимодействия с базой архивов, включая создание, удаление и обновление записей.

  **Общая информация**

  Модуль fp\_userlib\_archive предоставляет функцию для сохранения данных из CSV-файла в архив. Код написан на языке программирования Erlang. При возникновении ошибок транзакция будет отменена. Рекомендуется логировать информацию о процессе выполнения с использованием макросов:

- ?LOGINFO
- ?LOGWARNING
- ?LOGERROR

|**Функция**|**Описание**|
| :-: | :-: |
|csv\_to\_archive/1|<p>: Сохраняет данные из CSV-файла, переданного в виде строки в формате Base64, в архив.</p><p>**Параметры**:</p><p>- Args (map): Словарь с ключами:</p><p>- archive\_path (binary): Путь к архиву, куда будут записаны данные.</p><p>- content (binary): Содержимое CSV-файла в формате Base64.</p><p>&emsp;**Возвращает**: Атом ok в случае успешного выполнения или выбрасывает исключение в случае ошибки.</p><p>&emsp;**Пример использования**:</p><p>&emsp;Args = #{</p><p>&emsp;`  `<<"archive\_path">> => <<"/path/to/archive">>,</p><p>&emsp;`  `<<"content">> => <<"VGltZXN0YW1wLFZhbHVlCjE2NzMwMjUwMDAsMTIzLjQ1Cg==">> %% Base64-encoded CSV</p><p>&emsp;}.</p><p>&emsp;fp\_userlib\_archive:csv\_to\_archive(Args).</p><p>&emsp;**Детали реализации**:</p><p>- Декодирует содержимое CSV-файла из Base64 в бинарный формат.</p><p>- Разделяет данные на строки и колонки.</p><p>- Конвертирует данные времени (timestamp) и значений (value) в подходящие типы.</p><p>- Пытается записать обработанные данные в указанный архив с помощью функции fp\_archive:insert\_values.</p><p>- В случае ошибки записывает информацию в лог.</p><p>&emsp;</p>|
|||

**Примечания**

- Данные CSV-файла должны быть корректно закодированы в Base64.
- Архив, указанный в archive\_path, должен существовать и быть доступным для записи.
- В случае возникновения исключений данные не будут записаны.

  ## <a name="_heading=h.44sinio"></a>**А.4 Модуль fp\_pf\_utils**
  Вспомогательные функции для интеграции с PowerFactory (PF). Этот модуль помогает в управлении и мониторинге сетевых моделей, позволяя обмениваться данными между SCADA-системой и PF.

  **Общая информация**

  Модуль fp\_pf\_utils предоставляет функции для взаимодействия с PowerFactory Service. Основные функции включают операции для получения данных, выполнения расчётов и запуска динамических сценариев. Код написан на языке программирования Erlang. Все транзакции откатываются в случае ошибок, а успешное выполнение возвращает атом ok.

  Рекомендуется использовать следующие макросы для логирования:

- ?LOGINFO
- ?LOGWARNING
- ?LOGERROR

|**Функция**|**Описание**|
| :-: | :-: |
|pf\_get/0|<p>: Получает данные из PowerFactory на основе заданных параметров проекта.</p><p>**Параметры**: Нет.</p><p>**Возвращает**: Результат выполнения запроса к PowerFactory Service.</p><p>**Пример использования**:</p><p>fp\_pf\_utils:pf\_get().</p><p>**Детали реализации**:</p><p>- Формирует параметры проекта, включая имя сетки, имя проекта, имя сценария и тип сессии.</p><p>- Выполняет запрос через fp\_powerfactory\_service:pf\_service\_update с использованием хоста и порта.</p>|
|pf\_execute/0|<p>: Выполняет расчёт на основе заданных параметров проекта и указания идентификатора LDF.</p><p>**Параметры**: Нет.</p><p>**Возвращает**: Результат выполнения запроса к PowerFactory Service.</p><p>**Пример использования**:</p><p>fp\_pf\_utils:pf\_execute().</p><p>**Детали реализации**:</p><p>- Формирует параметры проекта, включая имя сетки, имя проекта, имя сценария и тип сессии.</p><p>- Определяет идентификатор объекта ComLdfOID для выполнения расчёта.</p><p>- Выполняет запрос через fp\_powerfactory\_service:pf\_service\_update с использованием хоста и порта.</p><p>&emsp;</p>|
|pf\_dynamics/0|<p>: Запускает динамический сценарий расчёта на основе заданных параметров проекта.</p><p>**Параметры**: Нет.</p><p>**Возвращает**: Результат выполнения запроса к PowerFactory Service.</p><p>**Пример использования**:</p><p>fp\_pf\_utils:pf\_dynamics().</p><p>**Детали реализации**:</p><p>- Формирует параметры проекта, включая имя сетки, имя проекта, имя сценария и тип сессии.</p><p>- Выполняет запрос через fp\_powerfactory\_service:pf\_service\_update с использованием хоста и порта.</p>|

**Примечания**

- Хост и порт для запросов определены через макросы ?HOST и ?PORT.
- Перед использованием функций убедитесь, что PowerFactory Service доступен по указанным параметрам.

  ## <a name="_heading=h.2jxsxqh"></a>**А.5 Модуль bms\_service**
  Логика сервиса для системы рынка баланса. Этот модуль управляет обменом данными с балансирующим рынком, обрабатывая данные о спросе и предложении.

  **Общая информация**

  Модуль bms\_service предоставляет функции для интеграции с REST API и обработки данных из внешних систем. Код написан на языке Erlang. Все методы модуля работают с объектами, позволяют редактировать их и обеспечивают откат транзакций в случае ошибок. Логирование рекомендуется выполнять с использованием макросов ?LOGINFO, ?LOGWARNING и ?LOGERROR.

|**Функция**|**Описание**|
| :-: | :-: |
|find\_objects/1|<p>: Ищет объекты в хранилище данных на основе переданных фильтров.</p><p>**Параметры**:</p><p>- Filter (map): Словарь, содержащий ключи:</p><p>- <<".path">>: Корневой путь объекта.</p><p>- <<".name">>: Имя объекта.</p><p>- <<".prototype">>: Прототип объекта.</p><p>&emsp;**Возвращает**: Список объектов, соответствующих заданным фильтрам, либо {error, [[], []]} в случае ошибки.</p><p>&emsp;**Пример использования**:</p><p>&emsp;Filter = #{</p><p>&emsp;`  `<<".path">> => <<"/root/PROJECT/">>,</p><p>&emsp;`  `<<".name">> => <<"subject">>,</p><p>&emsp;`  `<<".prototype">> => <<"/root/FP/prototypes/subject/fields">></p><p>&emsp;}.</p><p>&emsp;bms\_service:find\_objects(Filter).</p><p>&emsp;</p>|
|run/0|<p>: Основная функция для выполнения задачи. Осуществляет получение объектов, авторизацию через REST API, запрос данных и запись их в архивы.</p><p>**Параметры**: Нет.</p><p>**Возвращает**: Атом ok при успешном выполнении, либо описание ошибки.</p><p>**Пример использования**:</p><p>bms\_service:run().</p><p>**Детали реализации**:</p><p>- Формирует фильтры для поиска объектов.</p><p>- Выполняет запрос для получения токена авторизации через REST API.</p><p>- Осуществляет запрос данных по объектам с использованием токена.</p><p>- Преобразует полученные данные и записывает их в архивы.</p><p>&emsp;</p>|
|write\_to\_db/2|<p>: Записывает данные в хранилище данных, удаляя старые записи в указанном диапазоне.</p><p>**Параметры**:</p><p>- Data (list): Список данных для записи.</p><p>- Archive (binary): Путь к архиву.</p><p>&emsp;**Возвращает**: {ok, written\_to\_db} при успешной записи либо {error, {write\_failure, Reason}} при ошибке.</p><p>&emsp;**Пример использования**:</p><p>&emsp;bms\_service:write\_to\_db(Data, Archive).</p><p>&emsp;</p>|
|extract\_data/2|<p>: Извлекает и преобразует данные из ответа API для последующей обработки.</p><p>**Параметры**:</p><p>- Objects (list): Список объектов для обработки.</p><p>- Response (map): Ответ от REST API.</p><p>&emsp;**Возвращает**: Преобразованные данные или ok, если дата не соответствует требованиям.</p><p>&emsp;**Пример использования**:</p><p>&emsp;bms\_service:extract\_data(Objects, Response).</p>|

**Примечания**

- Функции transform\_purchases/2 и transform\_sales/2 используются для преобразования данных покупок и продаж в формате {Timestamp, Value}.
- Убедитесь, что REST API доступен и корректно настроен для выполнения запросов.
- Все временные метки преобразуются в миллисекунды для использования в архивах.
- При работе с датами используются вспомогательные функции is\_today/1 и is\_tomorrow/1 для определения актуальности данных.

  ## <a name="_heading=h.z337ya"></a>**А.6 Модуль calculation (v2)**
  Модуль для выполнения различных вычислений. Поддерживает более сложные операции, включая обработку данных в режиме реального времени.

  **Общая информация**

  Модуль calculation предоставляет функцию для вычисления значений на основе строки, содержащей арифметические операции, такие как сложение и вычитание. Код написан на языке Erlang и включает обработку ошибок и логирование. Основная цель — обработка строк с числами и получение вычисленного результата.

|**Функция**|**Описание**|
| :-: | :-: |
|evaluate/2|<p>: Выполняет вычисление на основе переданной строки с арифметическими операциями.</p><p>**Параметры**:</p><p>- Name (binary): Имя объекта, которое используется для получения дополнительных значений.</p><p>- String (binary): Строка с числами и арифметическими операциями (+ и -).</p><p>&emsp;**Возвращает**: Вычисленное числовое значение или {error, Reason} в случае ошибки.</p><p>&emsp;**Пример использования**:</p><p>&emsp;calculation:evaluate(<<"example">>, <<"10+20-5">>).</p><p>&emsp;**Детали реализации**:</p><p>- Проверяет, является ли String бинарной строкой.</p><p>- Разбивает строку на токены с помощью функции tokenize/1.</p><p>- Передаёт токены в функцию evaluate\_tokens/2 для выполнения вычислений.</p><p>- Логирует ошибки, если они возникают.</p>|
|tokenize/1|<p>: Разбивает строку на токены по операторам + и -.</p><p>**Параметры**:</p><p>- String (binary): Входная строка.</p><p>&emsp;**Возвращает**: Список токенов в виде бинарных строк.</p><p>&emsp;**Пример использования**:</p><p>&emsp;calculation:tokenize(<<"10+20-5">>).</p><p>&emsp;</p>|
|evaluate\_tokens/2|<p>: Выполняет вычисление на основе списка токенов.</p><p>**Параметры**:</p><p>- Name (binary): Имя объекта.</p><p>- Tokens (list): Список токенов (числа, операторы + и -).</p><p>&emsp;**Возвращает**: Результат вычисления.</p><p>&emsp;**Пример использования**:</p><p>&emsp;calculation:evaluate\_tokens(<<"example">>, [<<"10">>, <<"+">>, <<"20">>, <<"-">>, <<"5">>]).</p><p>&emsp;</p>|
|get\_value/1|<p>: Получает значение поля out\_value из объекта в хранилище данных.</p><p>**Параметры**:</p><p>Token (binary): Путь к объекту в виде строки.</p><p>**Возвращает**: Значение поля out\_value или вызывает исключение в случае ошибки.</p><p>**Пример использования**:</p><p>calculation:get\_value(<<"/root/FP/PROJECT/example">>).</p><p></p>|
|get\_catalog/2|<p>: Получает значение из каталога формул и вычисляет его, если оно содержит арифметическое выражение.</p><p>**Параметры**:</p><p>- Name (binary): Имя объекта.</p><p>- Token (binary): Идентификатор формулы.</p><p>&emsp;**Возвращает**: Числовое значение или результат вычисления.</p><p>&emsp;**Пример использования**:</p><p>&emsp;calculation:get\_catalog(<<"example">>, <<"formula\_1">>).</p><p>&emsp;</p>|
|split\_path/1|<p>: Разделяет путь на папку и имя объекта.</p><p>**Параметры**:</p><p>- Bin (binary): Полный путь к объекту.</p><p>&emsp;**Возвращает**: Кортеж {Folder, Name}.</p><p>&emsp;**Пример использования**:</p><p>&emsp;calculation:split\_path(<<"/root/FP/PROJECT/example">>).</p><p>&emsp;</p>|
|strings\_to\_binaries/1|<p>: Преобразует список строк в список бинарных строк.</p><p>**Параметры**:</p><p>- Strings (list): Список строк.</p><p>&emsp;**Возвращает**: Список бинарных строк.</p><p>&emsp;**Пример использования**:</p><p>&emsp;calculation:strings\_to\_binaries(["10", "+", "20", "-", "5"]).</p>|
|token\_is\_docker/1|<p>: Проверяет, является ли токен идентификатором объекта в системе Docker.</p><p>**Параметры**:</p><p>- Token (binary): Токен для проверки.</p><p>&emsp;**Возвращает**: true или false.</p><p>&emsp;**Пример использования**:</p><p>&emsp;calculation:token\_is\_docker(<<"/docker/object">>).</p>|
|token\_type/1|<p>: Определяет тип токена (целое число, число с плавающей точкой или неизвестный тип).</p><p>**Параметры**:</p><p>- Token (binary): Токен для анализа.</p><p>&emsp;**Возвращает**: int, float или false.</p><p>&emsp;**Пример использования**:</p><p>&emsp;calculation:token\_type(<<"10.5">>).</p><p>&emsp;</p>|

**Примечания**

- Убедитесь, что входная строка корректно сформирована и содержит только поддерживаемые операторы и числа.
- В случае ошибок вызовите логирование для диагностики причин.
- Функции работают с бинарными строками, поэтому при вводе данных убедитесь, что строки находятся в правильном формате.

  ## <a name="_heading=h.3j2qqm3"></a>**А.7 Модуль docker\_client (v0.1)**
  Клиент для взаимодействия с Docker. Используется для управления контейнерами Docker из среды Faceplate Studio, что удобно для разворачивания и мониторинга приложений в контейнерах.

  **Общая информация**

  Модуль docker\_client предоставляет интерфейс для взаимодействия с Docker Engine через API. Функции модуля позволяют получать список контейнеров, создавать и запускать контейнеры. Код написан на языке Erlang.

|**Функция**|**Описание**|
| :-: | :-: |
|list\_containers/0|<p>: Возвращает список контейнеров, запущенных в Docker Engine.</p><p>**Параметры**: Нет.</p><p>**Возвращает**:</p><p>- {ok, Containers}: Список контейнеров в формате JSON.</p><p>- {error, {unexpected\_status, StatusCode}}: Неожиданный HTTP-код ответа.</p><p>- {error, Reason}: Причина ошибки при выполнении запроса.</p><p>&emsp;**Пример использования**:</p><p>&emsp;docker\_client:list\_containers().</p><p>&emsp;**Детали реализации**:</p><p>- Формирует URL для запроса /containers/json.</p><p>- Выполняет HTTP GET-запрос.</p><p>- Декодирует ответ JSON или возвращает ошибку при некорректном статусе.</p>|
|create\_container/1|<p>: Создаёт новый контейнер на основе указанного образа.</p><p>**Параметры**:</p><p>- Image (binary): Имя образа Docker.</p><p>&emsp;**Возвращает**:</p><p>- {ok, ContainerInfo}: Информация о созданном контейнере.</p><p>- {error, {unexpected\_status, StatusCode}}: Неожиданный HTTP-код ответа.</p><p>- {error, Reason}: Причина ошибки при выполнении запроса.</p><p>&emsp;**Пример использования**:</p><p>&emsp;docker\_client:create\_container(<<"nginx">>).</p><p>&emsp;**Детали реализации**:</p><p>- Формирует URL для запроса /containers/create.</p><p>- Кодирует тело запроса в формате JSON, включая имя образа и команду.</p><p>- Выполняет HTTP POST-запрос.</p><p>- Декодирует ответ JSON или возвращает ошибку при некорректном статусе.</p>|
|start\_container/1|<p>: Запускает контейнер с указанным идентификатором.</p><p>**Параметры**:</p><p>- ContainerId (binary): Идентификатор контейнера.</p><p>&emsp;**Возвращает**:</p><p>- {ok, <<"Container started successfully">>}: Контейнер успешно запущен.</p><p>- {error, {unexpected\_status, StatusCode}}: Неожиданный HTTP-код ответа.</p><p>- {error, Reason}: Причина ошибки при выполнении запроса.</p><p>&emsp;**Пример использования**:</p><p>&emsp;docker\_client:start\_container(<<"e90e34656806">>).</p><p>&emsp;**Детали реализации**:</p><p>- Формирует URL для запроса /containers/{ContainerId}/start.</p><p>- Выполняет HTTP POST-запрос.</p><p>- Возвращает сообщение об успешном запуске или ошибку при некорректном статусе.</p>|

**Конфигурация**

**Базовый URL**: Определён через макрос ?DOCKER\_URL и по умолчанию равен http://localhost:2375.

**Примечания**

- Для работы функций требуется, чтобы Docker API был доступен по указанному адресу.
- Функции используют библиотеку HTTP клиента httpc и JSON-парсер jsx.
- В случае ошибок рекомендуется использовать логирование с помощью макросов ?LOGINFO, ?LOGWARNING, ?LOGERROR.

  ## <a name="_heading=h.1y810tw"></a>**А.8 Модуль fp\_powerfactory\_service**
  Модуль для интеграции с PowerFactory (PF).

  **Общая информация**

  Модуль fp\_powerfactory\_service предназначен для интеграции SCADA-системы Faceplate с расчетным ПО PowerFactory. Он обеспечивает обмен данными между этими системами посредством формирования, отправки и обработки JSON-запросов через промежуточный сервер server.py.

|**Функция**|**Описание**|
| :-: | :-: |
|pf\_service\_update(Params, [OID], Host, Port)|<p>**Параметры:**</p><p>Params: Должен содержать структуру следующего вида:</p><p>#{ </p><p>`     	`<<"study\_case\_name">> =></p><p><<"Study Case">>,</p><p>`    `<<"session\_type">></p><p>=> <<"calculation">>,</p><p>`    `<<"project\_name">></p><p>=> <<".MODEL\_SCADA\_V1107\_\_\_DEMO(1)">>,</p><p>`    `<<"operation\_scenario\_name">></p><p>=> <<"dyn">>,</p><p>`    `<<"id">> => 1,</p><p>`    `<<"grid\_name">></p><p>=> "Grid",</p><p>`    `<<"func\_name">></p><p>=> "get"</p><p>},</p><p>где "func\_name" должно содержать имя функции, которая используется для формирования json, поле "id" должно содержать идентификатор текущего экземпляра faceplate, остальные поля должны содержать параметры проекта PowerFactory, который будет использоваться для расчетов.</p><p>[OID]: Может содержать либо пустой erlang лист, либо OID передаваемого объекта.</p><p>Host и Port: адрес и порт сервера, на котором должен быть запущен server.py.</p><p>**Возвращает**: Json-результат выполнения запроса.</p><p>**Пример использования:**</p><p>fp\_powerfactory\_service:pf\_service\_update(Params, [], "127.0.0.1", 8080).</p><p>**Детали реализации**:</p><p>Данная функция не создает новые объекты в хранилище данных Faceplate, если объекты в принятом от PowerFactory json не найдены в базе данных Faceplate.</p>|
|pf\_service\_create\_update(Params, [OID], Host, Port)|<p>: Создает новые объекты в хранилище данных Faceplate, если объекты в принятом от PowerFactory json не найдены в хранилище данных Faceplate. </p><p>**Параметры:**</p><p>Params: Должен содержать структуру следующего вида:</p><p>#{ </p><p>`     	`<<"study\_case\_name">> =></p><p><<"Study Case">>,</p><p>`    `<<"session\_type">></p><p>=> <<"calculation">>,</p><p>`    `<<"project\_name">></p><p>=> <<".MODEL\_SCADA\_V1107\_\_\_DEMO(1)">>,</p><p>`    `<<"operation\_scenario\_name">></p><p>=> <<"dyn">>,</p><p>`    `<<"id">> => 1,</p><p>`    `<<"grid\_name">></p><p>=> "Grid",</p><p>`    `<<"func\_name">></p><p>=> "get"</p><p>},</p><p>где "func\_name" должно содержать имя функции, которая используется для формирования json, поле "id" должно содержать идентификатор текущего экземпляра faceplate, остальные поля должны содержать параметры проекта PowerFactory, который будет использоваться для расчетов.</p><p>[OID]: Может содержать либо пустой erlang лист, либо OID передаваемого объекта.</p><p>Host и Port: адрес и порт сервера, на котором должен быть запущен server.py.</p><p>**Возвращает**: Json-результат выполнения запроса.</p><p>**Пример использования:**</p><p>fp\_powerfactory\_service:pf\_service\_create\_update(Params, [], "127.0.0.1", 8080).</p><p>**Детали реализации**:</p><p>Может использоваться для создания объектов в каталогах (например, для загрузки библиотеки базовых типов из PowerFactory).</p>|
|pf\_service\_get\_section(ts, funct)|<p>: предназначена для формирования так называемого "среза" данных. Срез данных представляет собой json, сформированный по принципам, описанным в п.6.1.</p><p>Отличия заключается в том, что данные для формирования json извлекаются не из полей объектов Faceplate, а из соответствующих этим полям архивов.</p><p>**Параметры:**</p><p>ts: Определяет момент времени, для которого нужно получить данные.</p><p>funct: Содержит название функции, которая используется для формирования json (см. п 6.1).</p><p>**Возвращает:**<br>Json-объект с данными за указанный момент времени.</p><p>**Пример использования:**</p><p>fp\_powerfactory\_service:pf\_service\_get\_section(1669387200, "get\_section").</p><p>**Детали реализации:**<br>Принципы формирования Json соответствуют описанию в п. 6.1, с той разницей, что данные извлекаются не из полей объектов Faceplate, а из архивов.</p>|

## <a name="_heading=h.26yv2xnoh7n4"></a>**А.9 Модуль fp\_powerfactory\_service\_old**
Модуль для интеграции с PowerFactory (PF). Версия предназначена для работы с более старым функционалом PF.

**Общая информация**

Модуль fp\_powerfactory\_service\_old предоставляет API для интеграции с PowerFactory. Его функциональность включает управление каталогами оборудования, вызов функций PowerFactory и обработку связанных данных. Код написан на языке Erlang и включает механизмы логирования и обработки ошибок.

|**Функция**|**Описание**|
| :-: | :-: |
|on\_init/0|<p>: Инициализирует модуль, добавляя JSON-API для взаимодействия с PowerFactory.</p><p>**Параметры**: Нет.</p><p>**Возвращает**: Атом ok при успешной инициализации.</p><p>**Пример использования**:</p><p>fp\_powerfactory\_service\_old:on\_init().</p>|
|power\_factory\_import\_equipment\_library/1|<p>: Импортирует библиотеку оборудования в PowerFactory.</p><p>**Параметры**:</p><p>- {CatalogName, PFProjectParamsPath}: Кортеж, содержащий имя каталога и путь к параметрам проекта PowerFactory.</p><p>&emsp;**Возвращает**: Результат выполнения функции.</p><p>&emsp;**Пример использования**:</p><p>&emsp;fp\_powerfactory\_service\_old:power\_factory\_import\_equipment\_library({<<"CatalogName">>, <<"/path/to/project/params">>}).</p>|
|get\_equipment\_library\_catalog/1|<p>: Возвращает идентификаторы содержимого и полей каталога оборудования.</p><p>**Параметры**:</p><p>- CatalogName (binary): Имя каталога.</p><p>&emsp;**Возвращает**:</p><p>- {ContentOID, FieldsOID}: Кортеж с идентификаторами содержимого и полей каталога.</p><p>- Выбрасывает исключение, если каталог не найден.</p><p>&emsp;**Пример использования**:</p><p>&emsp;fp\_powerfactory\_service\_old:get\_equipment\_library\_catalog(<<"CatalogName">>).</p>|
|power\_factory\_call\_function/1|<p>: Выполняет вызов функции PowerFactory.</p><p>**Параметры**:</p><p>- {Context, PFProjectParamsPath, FunctionName}: Кортеж, содержащий контекст, путь к параметрам проекта и имя функции.</p><p>&emsp;**Возвращает**: Результат вызова функции в формате HTTP-ответа.</p><p>&emsp;**Пример использования**:</p><p>&emsp;fp\_powerfactory\_service\_old:power\_factory\_call\_function({Context, <<"/path/to/params">>, <<"function\_name">>}).</p>|
|power\_factory\_call\_function\_old/1|<p>: Устаревший метод вызова функции PowerFactory с дополнительным логированием.</p><p>**Параметры**:</p><p>- {Context, PFProjectParamsPath, FunctionName}: Кортеж, содержащий контекст, путь к параметрам проекта и имя функции.</p><p>&emsp;**Возвращает**: Результат вызова функции в формате HTTP-ответа.</p><p>&emsp;**Пример использования**:</p><p>&emsp;fp\_powerfactory\_service\_old:power\_factory\_call\_function\_old({Context, <<"/path/to/params">>, <<"function\_name">>}).</p>|
|get\_pf\_project\_params/1|<p>: Возвращает параметры проекта PowerFactory.</p><p>**Параметры**:</p><p>- PFProjectParamsPath (binary): Путь к параметрам проекта.</p><p>&emsp;**Возвращает**: Словарь с параметрами проекта.</p><p>&emsp;**Пример использования**:</p><p>&emsp;fp\_powerfactory\_service\_old:get\_pf\_project\_params(<<"/path/to/project/params">>).</p>|
|load\_config/0|<p>: Загружает конфигурацию модуля из файла.</p><p>**Параметры**: Нет.</p><p>**Возвращает**: Словарь с конфигурацией.</p><p>**Пример использования**:</p><p>Config = fp\_powerfactory\_service\_old:load\_config().</p><p></p>|
|get\_json/4|<p>: Формирует JSON-объект для передачи в PowerFactory.</p><p>**Параметры**:</p><p>- Config (map): Конфигурация.</p><p>- OIDsByElement (map): Сопоставление элементов и их идентификаторов.</p><p>- PFFunc (binary): Имя функции PowerFactory.</p><p>- PFProjectParams (map): Параметры проекта.</p><p>&emsp;**Возвращает**: JSON-объект.</p><p>&emsp;**Пример использования**:</p><p>&emsp;JSON = fp\_powerfactory\_service\_old:get\_json(Config, OIDsByElement, <<"function\_name">>, PFProjectParams).</p>|
|http\_send/4|<p>: Отправляет HTTP-запрос на сервер PowerFactory.</p><p>**Параметры**:</p><p>- RemoteServiceParams (map): Параметры удалённого сервиса.</p><p>- Path (binary): Путь запроса.</p><p>- Data (binary): Тело запроса в формате JSON.</p><p>- ResponseFun (fun): Функция для обработки ответа.</p><p>&emsp;**Возвращает**: Результат выполнения запроса.</p><p>&emsp;**Пример использования**:</p><p>&emsp;fp\_powerfactory\_service\_old:http\_send(RemoteServiceParams, <<"api/path">>, Data, fun(Response) -> io:format("~p", [Response]) end).</p>|

**Примечания**

- Для корректной работы модуля необходимо наличие конфигурационного файла fp2pf\_mapping.json.
- Все функции обеспечивают обработку ошибок и логирование через макросы ?LOGINFO, ?LOGWARNING и ?LOGERROR.
- Методы HTTP-запросов используют библиотеку httpc для взаимодействия с удалёнными сервисами.

  ## <a name="_heading=h.4i7ojhp"></a>**А.10 Модуль fp\_state\_estimation\_service**
  Сервис для оценки состояния (State Estimation, SE). Используется для вычисления текущего состояния системы, позволяя определять узкие места и потенциальные сбои в сети.

  **Общая информация**

  Модуль fp\_state\_estimation\_service предназначен для управления процессом оценивания состояния (state estimation) в системе. Он реализует экспорт и импорт данных в формате JSON, настройку и запуск вспомогательных утилит, а также предоставляет функции взаимодействия с хранилищами данных.

  Этот модуль используется для интеграции системы управления с процессами анализа данных, включая передачу и обработку информации о параметрах узлов и линий, а также получение статистики работы системы.

|**Функция**|**Описание**|
| :-: | :-: |
|**on\_init/0**|<p>: Инициализирует API для вызова функций модуля через JSON-запросы. Функция должна быть вызвана при запуске системы.</p><p>**Параметры**: Нет.</p><p>**Возвращает**:</p><p>- ok — если инициализация завершилась успешно.</p><p>&emsp;**Пример использования**:</p><p>&emsp;fp\_state\_estimation\_service:on\_init().</p>|
|**export\_json/1**|<p>: Экспортирует данные системы в формате JSON, создавая файл для последующего анализа или передачи в другие модули.</p><p>**Параметры**:</p><p>- {StartParams, AParams, CommonSettingsPath, SSEStatPath}:</p><p>- StartParams — карта начальных параметров (например, временные диапазоны).</p><p>- AParams — дополнительные параметры (например, настройки фильтров).</p><p>- CommonSettingsPath — путь к объекту общих настроек.</p><p>- SSEStatPath — путь к объекту статистики.</p><p>&emsp;**Возвращает**:</p><p>- ok — если экспорт выполнен успешно.</p><p>- Логирует ошибку в случае сбоя при записи файла или при некорректных параметрах.</p><p>&emsp;**Пример использования**:</p><p>&emsp;StartParams = #{<<"start\_time">> => <<"2024-01-01T00:00:00">>, <<"end\_time">> => <<"2024-01-01T12:00:00">>},</p><p>&emsp;AParams = #{<<"region">> => <<"North">>},</p><p>&emsp;CommonSettingsPath = <<"/root/FP/PROJECT/settings/common">>,</p><p>&emsp;SSEStatPath = <<"/root/FP/PROJECT/statistics/se\_stats">>,</p><p>&emsp;</p><p>&emsp;fp\_state\_estimation\_service:export\_json({StartParams, AParams, CommonSettingsPath, SSEStatPath}).</p>|
|**import\_json/1**|<p>: Импортирует данные из JSON-файла в храниище данных системы. Используется для обновления информации о параметрах узлов, линий и статистики.</p><p>**Параметры**:</p><p>- SSEStatPath — путь к объекту статистики.</p><p>&emsp;**Возвращает**:</p><p>- ok — если импорт завершен успешно.</p><p>- Логирует ошибки при сбоях.</p><p>&emsp;**Пример использования**:</p><p>&emsp;SSEStatPath = <<"/root/FP/PROJECT/statistics/se\_stats">>,</p><p>&emsp;fp\_state\_estimation\_service:import\_json(SSEStatPath).</p>|
|**import\_json\_for\_demo/1**|<p>: Импортирует данные для демонстрации. Отличается от обычного импорта выбором файла в зависимости от текущего состояния системы.</p><p>**Параметры**:</p><p>- SourceFiles — список путей к JSON-файлам.</p><p>&emsp;**Возвращает**:</p><p>- ok — если данные успешно импортированы.</p><p>&emsp;**Пример использования**:</p><p>&emsp;SourceFiles = [<<"/path/to/demo1.json">>, <<"/path/to/demo2.json">>],</p><p>&emsp;fp\_state\_estimation\_service:import\_json\_for\_demo(SourceFiles).</p>|
|**run\_se\_util/1**|<p>: Запускает утилиту для выполнения процессов state estimation.</p><p>**Параметры**:</p><p>- \_Arg — аргумент, зарезервированный для будущих реализаций (на текущий момент игнорируется).</p><p>&emsp;**Возвращает**:</p><p>- ok — если утилита выполнена успешно.</p><p>- Логирует предупреждение, если путь к утилите не указан.</p><p>&emsp;**Пример использования**:</p><p>&emsp;fp\_state\_estimation\_service:run\_se\_util({}).</p>|
|**run\_se/1**|<p>: Оркестрирует полный процесс запуска state estimation. Включает экспорт данных, запуск утилиты и последующий импорт результатов.</p><p>**Параметры**:</p><p>- {Path, StartParams, AParams, CommonSettingsPath, SSEStatPath}:</p><p>- Path — путь к рабочему каталогу.</p><p>- StartParams — начальные параметры.</p><p>- AParams — дополнительные параметры.</p><p>- CommonSettingsPath — путь к объекту настроек.</p><p>- SSEStatPath — путь к статистике.</p><p>&emsp;**Возвращает**:</p><p>- ok — если весь процесс завершен успешно.</p><p>- Логирует ошибки при сбоях.</p><p>&emsp;**Пример использования**:</p><p>&emsp;Path = <<"/home/master/forSE">>,</p><p>&emsp;StartParams = #{<<"start\_time">> => <<"2024-01-01T00:00:00">>},</p><p>&emsp;AParams = #{<<"region">> => <<"East">>},</p><p>&emsp;CommonSettingsPath = <<"/root/FP/PROJECT/settings/common">>,</p><p>&emsp;SSEStatPath = <<"/root/FP/PROJECT/statistics/se\_stats">>,</p><p>&emsp;</p><p>&emsp;fp\_state\_estimation\_service:run\_se({Path, StartParams, AParams, CommonSettingsPath, SSEStatPath}).</p>|
|**load\_config/0**|<p>: Загружает конфигурацию из JSON-файла state\_estimation\_settings.jsonc.</p><p>**Пример использования**:</p><p>Config = fp\_state\_estimation\_service:load\_config().</p>|
|**get\_absolute\_path/1**|<p>: Возвращает абсолютный путь к указанному файлу.</p><p>**Пример использования**:</p><p>AbsPath = fp\_state\_estimation\_service:get\_absolute\_path(<<"settings.jsonc">>).</p>|
|**load\_mapping/1**|<p>: Загружает настройки маппинга из файла.</p><p>**Пример использования**:</p><p>Mapping = fp\_state\_estimation\_service:load\_mapping(<<"mapping.jsonc">>).</p><p></p>|

**Примечания**

- Модуль интегрируется с внутренним хранилищем данных через протоколы, реализованные в платформе Faceplate.
- Все операции, связанные с чтением и записью, происходят транзакционно. В случае ошибки или сбоя транзакция откатывается.
- Для экспорта и импорта данных используются маппинг-файлы, описывающие соответствие структур данных системы и JSON.
- Перед использованием функций run\_se или run\_se\_util необходимо убедиться, что конфигурационные файлы и утилиты доступны.

  ## <a name="_heading=h.2xcytpi"></a>**А.11 Модуль string\_replace**
  Модуль для работы с текстовыми данными. Включает функции поиска и замены текста, что полезно для обработки текстовой информации в системе.

  **Общая информация**

  Модуль string\_replace предназначен для выполнения замены подстрок в строках объектов хранилища данных. Замена производится рекурсивно по заданным шаблонам и паттернам. Основная цель модуля — автоматизация обновления строк с использованием хранилища данных fp\_db.

|**Функция**|**Описание**|
| :-: | :-: |
|**replace\_in\_strings/2**|<p>: Производит замену всех вхождений строки ?SEARCH\_STR на ?REPLACE\_STR для объектов, соответствующих заданным корню и паттерну.</p><p>**Параметры**:</p><p>- Root (binary) — корневая папка, в пределах которой ищутся объекты для обработки.</p><p>- Pattern (binary) — паттерн объектов, указывающий на их прототип.</p><p>&emsp;**Возвращает**:</p><p>- NewContent (list) — список объектов с обновленными строками.</p><p>&emsp;**Детали реализации**:</p><p>- Из хранилища данных fp\_db выбираются объекты, соответствующие указанным Root и Pattern.</p><p>- Для каждого объекта производится проверка наличия строки ?SEARCH\_STR в поле screen.</p><p>- Если строка найдена, она заменяется на ?REPLACE\_STR. Изменение сохраняется в хранилище данных.</p><p>- Если строка не содержит ?SEARCH\_STR, объект остается неизменным.</p><p>&emsp;**Пример использования**:</p><p>&emsp;% Выполнение замены строк в объектах с прототипом "/root/FP/prototypes/substation/fields" в папке "KAZ/UZHNIY".</p><p>&emsp;Root = <<"KAZ/UZHNIY">>,</p><p>&emsp;Pattern = <<"/root/FP/prototypes/substation/fields">>,</p><p>&emsp;string\_replace:replace\_in\_strings(Root, Pattern).</p>|
|**replace/2**|<p>: Выполняет замену строки ?SEARCH\_STR на ?REPLACE\_STR в заданном объекте.</p><p>**Параметры**:</p><p>- OID — идентификатор объекта.</p><p>- String — строка, в которой выполняется поиск и замена.</p><p>&emsp;**Возвращает**:</p><p>- Если замена произведена, функция возвращает новую строку с замененными подстроками.</p><p>- Если строка не содержит ?SEARCH\_STR, возвращается исходная строка.</p><p>&emsp;**Детали реализации**:</p><p>- Проверяется, содержит ли строка ?SEARCH\_STR с помощью binary:matches.</p><p>- Если вхождение найдено:</p><p>&emsp;1) Производится замена всех вхождений на ?REPLACE\_STR с помощью binary:replace\.</p><p>&emsp;2) Обновленная строка записывается обратно в объект через fp\_db:edit\_object\.</p><p>- Если вхождений нет, строка остается без изменений.</p><p>&emsp;**Пример использования**:</p><p>&emsp;OID = fp\_db:to\_oid(<<"example\_oid">>),</p><p>&emsp;String = <<"This is a lib.update\_line example">>,</p><p>&emsp;string\_replace:replace(OID, String).</p>|
|**replace\_in\_string/1**|<p>: Обрабатывает строки, проверяя их на наличие подстроки ?SEARCH\_STR. В случае наличия выполняет замену, используя функцию replace/2.</p><p>**Параметры**:</p><p>- [OID, String] — список, содержащий идентификатор объекта и строку для обработки.</p><p>&emsp;**Возвращает**:</p><p>- Обновленный список [OID, NewString], где NewString — результат замены.</p><p>&emsp;**Пример использования**:</p><p>&emsp;replace\_in\_string([OID, <<"lib.update\_line example">>]).</p>|

**Пример использования модуля:**

% Устанавливаем константы для поиска и замены

-define(SEARCH\_STR, "lib.update\_line").

-define(REPLACE\_STR, "lib.updateNode").

% Задаем корень и паттерн

Root = <<"KAZ/UZHNIY">>,

Pattern = <<"/root/FP/prototypes/substation/fields">>,

% Запускаем процесс замены

string\_replace:replace\_in\_strings(Root, Pattern).

**Вывод:**

- Если совпадение найдено:

  Замена произведена: /path/to/object

- Если совпадений не найдено:

  Совпадение не найдено в строке объекта /path/to/object

  **Примечания**

- Константы:

    1) ?SEARCH\_STR — строка, которую необходимо заменить\.

    2) ?REPLACE\_STR — строка, на которую выполняется замена\.

- Поддерживается обработка строк, заданных в бинарном формате.
- Логирование результатов замены осуществляется через io:format.

  ## <a name="_heading=h.1ci93xb"></a>**А.12 Модуль model\_service\_v2**
  Новая версия сервиса для работы с моделями. Поддерживает управление несколькими архивами, а также интеграцию данных о погоде, предоставляя более широкие аналитические возможности.

  **Общая информация**

  Модуль model\_service\_v2 предназначен для выполнения заданий, связанных с обработкой данных моделей. Он предоставляет функционал для:

- Чтения данных из хранилища.
- Обработки данных с использованием внешних сервисов.
- Записи обработанных данных обратно в хранилище.

  Основной поток выполнения состоит из:

1. Подготовки данных для задачи.
1. Отправки данных на удалённый сервис.
1. Обработки ответа от сервиса.
1. Записи результата в хранилище данных.

|**Функция**|**Описание**|
| :-: | :-: |
|**run\_task/1**|<p>: Основная функция, запускающая выполнение задачи для указанного объекта. Производит полный цикл обработки: чтение, вызов внешнего сервиса и запись результата.</p><p>**Параметры**:</p><p>- Obj (OID объекта) — объект, для которого выполняется задача.</p><p>&emsp;**Возвращает**:</p><p>- ok — при успешном выполнении.</p><p>- {error, Reason} — при возникновении ошибки.</p><p>&emsp;**Детали реализации**:</p><p>- Считываются поля объекта, необходимые для выполнения задачи.</p><p>- Формируется набор временных меток для чтения данных из архива.</p><p>- Собирается JSON-запрос для внешнего сервиса.</p><p>- Выполняется HTTP-запрос на внешний сервис с заданными данными.</p><p>- Обрабатывается ответ от сервиса и записывается результат в хранилище данных.</p><p>&emsp;**Пример использования**:</p><p>&emsp;Obj = fp\_db:to\_oid(<<"object\_path">>),</p><p>&emsp;model\_service\_v2:run\_task(Obj).</p><p>&emsp;</p>|
|**call/2**|<p>: Функция для выполнения HTTP-запроса на внешний сервис.</p><p>**Параметры**:</p><p>- Url (binary) — URL сервиса.</p><p>- DataMap (map) — данные, отправляемые в теле запроса.</p><p>&emsp;**Возвращает**:</p><p>- {ok, Response} — успешный ответ от сервиса.</p><p>- {error, Reason} — ошибка при выполнении запроса.</p><p>&emsp;**Пример использования**:</p><p>&emsp;Url = <<"http://127.0.0.1:8000/predict">>,</p><p>&emsp;Data = #{<<"task\_id">> => <<"123">>, <<"task\_input">> => Dataset},</p><p>&emsp;model\_service\_v2:call(Url, Data).</p>|
|**read\_from\_db/3**|<p>: Считывает данные из архива за указанный временной диапазон.</p><p>**Параметры**:</p><p>- InputWindow (integer) — количество временных меток для чтения.</p><p>- Step (integer) — шаг между временными метками (в миллисекундах).</p><p>- Archive (OID) — архив, из которого считываются данные.</p><p>&emsp;**Возвращает**:</p><p>- Data (list) — список считанных данных.</p><p>- {error, Reason} — в случае ошибки.</p><p>&emsp;**Пример использования**:</p><p>&emsp;InputWindow = 24,</p><p>&emsp;Step = 3600000,  % 1 час</p><p>&emsp;Archive = fp\_db:to\_oid(<<"archive\_path">>),</p><p>&emsp;model\_service\_v2:read\_from\_db(InputWindow, Step, Archive).</p>|
|**write\_to\_db/2**|<p>: Записывает данные в архив.</p><p>**Параметры**:</p><p>- Data (list) — данные для записи.</p><p>- Archive (OID) — архив для записи данных.</p><p>&emsp;**Возвращает**:</p><p>- {ok, From, To} — диапазон временных меток записанных данных.</p><p>- {error, Reason} — ошибка при записи данных.</p><p>&emsp;**Пример использования**:</p><p>&emsp;Data = [{1669905600000, 1.23}, {1669909200000, 1.45}],</p><p>&emsp;Archive = fp\_db:to\_oid(<<"archive\_path">>),</p><p>&emsp;model\_service\_v2:write\_to\_db(Data, Archive).</p>|
|**transform/1**|<p>: Трансформирует данные в формат, подходящий для записи.</p><p>**Параметры**:</p><p>- Data (list) — входные данные.</p><p>&emsp;**Возвращает**:</p><p>- {ok, TransformedData} — успешная трансформация.</p><p>- {error, Reason} — ошибка трансформации.</p><p>&emsp;**Пример использования**:</p><p>&emsp;Data = [[1669905600, 1.23], [1669909200, 1.45]],</p><p>&emsp;model\_service\_v2:transform(Data).</p>|

**Пример использования модуля:**

% Устанавливаем объект

Obj = fp\_db:to\_oid(<<"object\_path">>),

% Запускаем выполнение задачи

model\_service\_v2:run\_task(Obj).

**Ожидаемый вывод в логах:**

1. Информация о начале задачи:

   model\_service: Run the task...

1. Успешное чтение данных:

   model\_service: read the object: #{<<"model\_state">> => <<"active">>, ...}

1. Успешный вызов внешнего сервиса:

   Response #{<<"task\_output">> => [[1669905600, 1.23], [1669909200, 1.45]]}

1. Успешная запись данных:

   Data successfully written to archive: <<"archive\_path">>

   **Примечания**

- Взаимодействие с внешним сервисом:

    1) URL сервиса формируется на основе хоста и порта\.

    2) Отправка данных осуществляется через HTTP POST запрос с JSON-телом\.

- Логирование:

    1) Все ключевые шаги процесса логируются с использованием макросов ?LOGINFO, ?LOGWARNING и ?LOGERROR\.

- Обработка ошибок:

  1)Если выполнение задачи прерывается на любом этапе, функция возвращает описание ошибки.

  ## <a name="_heading=h.3whwml4"></a>**А.13 Модуль rest\_api\_client (v1.0)**
  Клиент REST API для обмена данными с системой рынка баланса. Поддерживает запросы на сервер по протоколу REST и позволяет интегрировать данные с внешними REST API.

  **Общая информация**

  Модуль rest\_api\_client предназначен для выполнения HTTP-запросов к REST API, включая:

1. Получение токена для авторизации.
1. Выполнение запросов с использованием токена.

|**Функция**|**Описание**|
| :-: | :-: |
|**get\_token/2**|<p>: Получает токен для авторизации по указанному URL и телу запроса.</p><p>**Параметры**:</p><p>- TokenUrl (binary) — URL для получения токена.</p><p>- RequestBody (map) — тело запроса с данными для авторизации.</p><p>&emsp;**Возвращает**:</p><p>- {ok, Token} — если токен успешно получен.</p><p>- {error, no\_token\_in\_response} — если токен отсутствует в ответе.</p><p>- {error, Reason} — если произошла ошибка во время выполнения запроса.</p><p>&emsp;**Детали реализации**:</p><p>- Формирует тело запроса в формате JSON.</p><p>- Выполняет POST-запрос на указанный URL.</p><p>- Декодирует ответ и извлекает токен.</p><p>&emsp;**Пример использования**:</p><p>&emsp;TokenUrl = <<"http://api.example.com/auth/token">>,</p><p>&emsp;RequestBody = #{<<"username">> => <<"user">>, <<"password">> => <<"pass">>},</p><p>&emsp;rest\_api\_client:get\_token(TokenUrl, RequestBody).</p>|
|**make\_request/4**|<p>: Выполняет HTTP-запрос с использованием токена авторизации.</p><p>**Параметры**:</p><p>- Token (binary) — токен для авторизации.</p><p>- Method (atom) — HTTP-метод (get, post, put, delete).</p><p>- Url (binary) — URL для выполнения запроса.</p><p>- Body (map) — тело запроса.</p><p>&emsp;**Возвращает**:</p><p>- {ok, Response} — успешный ответ с декодированными данными.</p><p>- {error, {unexpected\_status, Code}} — неожиданный статус-код.</p><p>- {error, Reason} — ошибка при выполнении запроса.</p><p>&emsp;**Детали реализации**:</p><p>- Кодирует тело запроса в формат JSON.</p><p>- Формирует HTTP-запрос с заголовками, включая Authorization.</p><p>- Выполняет запрос и обрабатывает результат.</p><p>&emsp;**Пример использования**:</p><p>&emsp;Token = <<"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9">>,</p><p>&emsp;Method = post,</p><p>&emsp;Url = <<"http://api.example.com/data">>,</p><p>&emsp;Body = #{<<"key">> => <<"value">>},</p><p>&emsp;rest\_api\_client:make\_request(Token, Method, Url, Body).</p>|
|**get\_url/3**|<p>: Формирует URL для выполнения запросов.</p><p>**Параметры**:</p><p>- Host (binary) — адрес хоста.</p><p>- Port (binary) — порт хоста.</p><p>- URL (binary) — конечная точка.</p><p>&emsp;**Возвращает**:</p><p>- Сформированный URL (binary).</p><p>&emsp;**Пример использования**:</p><p>&emsp;Host = <<"127.0.0.1">>,</p><p>&emsp;Port = <<"8080">>,</p><p>&emsp;Path = <<"api/resource">>,</p><p>&emsp;rest\_api\_client:get\_url(Host, Port, Path).</p>|

**Примеры использования модуля.**

**Пример 1: Получение токена**

TokenUrl = <<"http://auth.example.com/token">>,

RequestBody = #{<<"username">> => <<"admin">>, <<"password">> => <<"secret">>},

case rest\_api\_client:get\_token(TokenUrl, RequestBody) of

`    `{ok, Token} -> io:format("Token received: ~p~n", [Token]);

`    `{error, Reason} -> io:format("Failed to get token: ~p~n", [Reason])

end.

**Пример 2: Выполнение запроса с токеном**

Token = <<"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9">>,

Method = post,

Url = <<"http://api.example.com/resource">>,

Body = #{<<"param1">> => <<"value1">>, <<"param2">> => <<"value2">>},

case rest\_api\_client:make\_request(Token, Method, Url, Body) of

`    `{ok, Response} -> io:format("Response: ~p~n", [Response]);

`    `{error, Reason} -> io:format("Request failed: ~p~n", [Reason])

end.

**Пример 3: Формирование URL**

Host = <<"127.0.0.1">>,

Port = <<"8080">>,

Path = <<"api/v1/resource">>,

Url = rest\_api\_client:get\_url(Host, Port, Path),

io:format("Generated URL: ~p~n", [Url]).

**Ожидаемые сценарии работы**

- Успешный запрос:

    1) Токен получен и запрос выполнен без ошибок\.

    2) Ответ: {ok, Response}\.

- Ошибка токена:

    1) Сервер не вернул токен\.

    2) Ответ: {error, no\_token\_in\_response}\.

- Ошибка запроса:

    1) Сервер вернул неожиданный статус-код или произошла ошибка подключения\.

    2) Ответ: {error, Reason}\.

  **Примечания**

- Формат данных:

    1) Данные запросов и ответов кодируются/декодируются в формате JSON с помощью библиотеки jsx\.

- Авторизация:

    1) Используется авторизация с токеном, передаваемым в заголовке Authorization\.

- Обработка ошибок:

    1) Ошибки логируются, и в случае неудачного запроса возвращаются соответствующие коды и описания\.

  ## <a name="_heading=h.2bn6wsx"></a>**А.14 Модуль state\_graph (v1)**
  Модуль для работы с графическим отображением состояний. Поддерживает функцию голосования (vote), позволяя принимать решения на основе текущих данных о состоянии объектов.

  **Общая информация**

  Модуль state\_graph предоставляет функционал для работы с цветами, связанными с состояниями и классами напряжения, извлечения класса напряжения из строки, а также вычисления среднего значения параметров из списка с учетом отклонений.

|**Функция**|**Описание**|
| :-: | :-: |
|**color/2**|<p>: Возвращает цвет в зависимости от класса напряжения и состояния.</p><p>**Параметры**:</p><p>- Vclass (integer) — класс напряжения.</p><p>- State (integer) — состояние.</p><p>&emsp;**Возвращает**:</p><p>- Цвет в виде строки (binary), например: <<"#959595">>.</p><p>&emsp;**Детали реализации**:</p><p>- Приводит State к числу, если это не так.</p><p>- Определяет цвет для заданного класса напряжения (Vclass) из предопределенной карты цветов.</p><p>- Возвращает цвет в зависимости от значения State.</p><p>&emsp;**Пример использования**:</p><p>&emsp;Vclass = 65,</p><p>&emsp;State = 2,</p><p>&emsp;state\_graph:color(Vclass, State).</p>|
|**get\_vclass\_from\_string/1**|<p>: Извлекает класс напряжения из строки.</p><p>**Параметры**:</p><p>- String (binary) — строка, содержащая класс напряжения.</p><p>&emsp;**Возвращает**:</p><p>- Класс напряжения (integer).</p><p>- 0, если класс напряжения не найден.</p><p>&emsp;**Детали реализации**:</p><p>1. Использует регулярное выражение для поиска чисел в строке.</p><p>2. Если совпадение найдено, преобразует его в число, иначе возвращает 0.</p><p>&emsp;**Пример использования**:</p><p>&emsp;String = <<"Voltage class: 110 kV">>,</p><p>&emsp;state\_graph:get\_vclass\_from\_string(String).</p>|
|**vote/3**|<p>: Вычисляет среднее значение параметров из списка, удовлетворяющих условию минимального отклонения от целевого значения.</p><p>**Параметры**:</p><p>- Values (list) — список чисел.</p><p>- Deviation (integer) — допустимое отклонение.</p><p>- TargetValue (integer) — целевое значение.</p><p>&emsp;**Возвращает**:</p><p>- Среднее значение (float) из фильтрованных значений.</p><p>- none, если подходящие значения отсутствуют.</p><p>&emsp;**Детали реализации**:</p><p>- Фильтрует значения, которые находятся в пределах Deviation от TargetValue.</p><p>- Если подходящих значений нет, возвращает none.</p><p>- Если одно значение удовлетворяет условию, возвращает его.</p><p>- Если несколько значений удовлетворяют условию, возвращает их среднее.</p><p>&emsp;**Пример использования**:</p><p>&emsp;Values = [110, 115, 120, 130],</p><p>&emsp;Deviation = 10,</p><p>&emsp;TargetValue = 115,</p><p>&emsp;state\_graph:vote(Values, Deviation, TargetValue).</p>|

**Примеры использования модуля**

**Пример 1: Определение цвета**

Vclass = 110,

State = 1,

Color = state\_graph:color(Vclass, State),

io:format("Цвет для класса напряжения ~p в состоянии ~p: ~p~n", [Vclass, State, Color]).

**Пример 2: Извлечение класса напряжения из строки**

String = <<"This is a voltage class: 220">>,

Vclass = state\_graph:get\_vclass\_from\_string(String),

io:format("Извлеченный класс напряжения: ~p~n", [Vclass]).

**Пример 3: Расчет среднего значения с учетом отклонений**

Values = [100, 105, 115, 130],

Deviation = 10,

TargetValue = 110,

Result = state\_graph:vote(Values, Deviation, TargetValue),

io:format("Среднее значение: ~p~n", [Result]).

**Ожидаемые сценарии работы**

- **Обработка цветов**: Если класс напряжения не найден в предопределенных значениях, возвращается цвет <<"#000000">> (черный). При некорректном состоянии (State) по умолчанию используется 0.
- **Извлечение данных из строки**: Если строка не содержит числовых данных, возвращается 0.
- **Фильтрация значений**: Если список значений пуст или не содержит подходящих элементов, возвращается none. При одном подходящем значении оно возвращается без изменений.

  **Примечания**

- **Обработка цветов**: Цвета ассоциируются с классами напряжения и состояниями, а если значения отсутствуют, используются цвета по умолчанию.
- **Работа со строками**: Класс напряжения извлекается из строки с помощью регулярных выражений.
- **Расчет среднего**: Фильтрация значений осуществляется на основе заданного допустимого отклонения.

  # <a name="_heading=h.qsh70q"></a>**Приложение Б. Faceplate API**
  Эта документация поможет эффективно использовать API для работы с объектами, архивами и хранилищем данных в SCADA/EMS.
  ## <a name="_heading=h.3as4poj"></a>**Б.1 Модули fp и fp\_db (fp\_api\_erlang.md)**
  **Общая информация**

  Модули fp и fp\_db предназначены для работы с объектами, архивами и хранилищем данных в среде SCADA/EMS. API предоставляет методы для преобразования данных, работы с объектами, чтения и изменения полей, а также выполнения запросов.

  Функции модуля оптимизированы для использования в RunTime и могут работать быстрее за счет кеширования данных.

|**Функция**|**Описание**|
| - | - |
|fp:to\_json/1|<p>**:** Преобразует Erlang-терм (список, map, числа) в JSON.</p><p>**Возвращает:** binary в формате JSON.</p><p>**Пример использования:**</p><p>JSON = fp:to\_json(#{key => "value"}).</p>|
|fp:from\_json/1|<p>**:** Конвертирует JSON (в формате binary) обратно в Erlang-терм.<br>**Возвращает:** Термин (например, список, map, числа).</p><p>**Пример использования:**</p><p>Term = fp:from\_json(<<"{\"key\":\"value\"}">>).</p>|
|fp:open\_tag/1|<p>**:** Открывает объект тега по указанному пути. Работает быстрее fp\_db:open/1, благодаря кешированию.</p><p>**Требование:** Работает только в режиме RunTime.</p><p>**Возвращает:** {ok, Object}.</p><p>**Пример использования:**</p><p>{ok, Tag} = fp:open\_tag("/path/to/tag").</p>|
|fp:get\_value/2|<p>**:** Получает значение поля объекта по пути к тегу. Работает быстрее, чем fp\_db:read\_field.</p><p>**Требование:** Работает только в режиме RunTime.</p><p>**Возвращает:** {ok, Value}.</p><p>**Пример использования:**</p><p>{ok, Value} = fp:get\_value(Tag, Field).</p>|
|fp:get\_value/3|<p>**:** Аналог fp:get\_value/2, но возвращает значение Default, если поле не задано.</p><p>**Возвращает:** {ok, Value}.</p><p>**Пример использования:**</p><p>{ok, Value} = fp:get\_value(Tag, Field, DefaultValue).</p>|
|fp:set\_value/2|<p>**:** Изменяет значения полей тега.</p><p>**Требование:** Работает только в режиме RunTime.</p><p>**Принимает:**</p><p>- TagPath — путь к тегу.</p><p>- Changes — список пар {Field, Value}.</p><p>&emsp;**Возвращает:** ok.</p><p>&emsp;**Пример использования:**</p><p>&emsp;ok = fp:set\_value("/path/to/tag", [{field1, value1}, {field2, value2}]).</p>|
|fp:set\_value/3|<p>**:** Присваивает конкретное значение полю объекта.</p><p>**Требование:** Работает только в режиме RunTime.</p><p>**Возвращает:** ok.</p><p>**Пример использования:**</p><p>ok = fp:set\_value("/path/to/tag", field, value).</p>|
|fp:archives\_get/2|<p>**:** Возвращает значения архивов для указанных точек в заданных моментах времени.</p><p>**Возвращает:** Список списков формата:</p><p>` `[[TS1, A1\_value, A2\_value, ...], ...].</p><p>**Пример использования:**</p><p>Data = fp:archives\_get(Points, Archives).</p>|
|fp:archive\_get\_point/2|<p>**:** Получает значение из архива в заданный момент времени.</p><p>**Возвращает:** {TS, Value}.</p><p>**Пример использования:**</p><p>{Timestamp, Value} = fp:archive\_get\_point(Archive, Timestamp).</p>|
|fp:archives\_get\_periods/2|<p>**:** Возвращает значения архивов за периоды, настроенные через Params.</p><p>**Возвращает:** Список списков формата:</p><p>` `[[TS1, A1\_value, A2\_value, ...], ...].</p><p>**Пример использования:**</p><p>Data = fp:archives\_get\_periods(Params, Archives).</p>|
|fp:version/0|<p>**:** Возвращает текущую версию API.</p><p>**Возвращает:** Версию в формате Version.</p><p>**Пример использования:**</p><p>Version = fp:version().</p>|
|fp\_db:create\_object/1|<p>**:** Создаёт объект с заданными полями.</p><p>**Возвращает:** Объект.</p><p>**Пример использования:**</p><p>Object = fp\_db:create\_object(#{field1 => value1, field2 => value2}).</p>|
|fp\_db:read\_field/2|<p>**:** Читает значение поля объекта.</p><p>**Возвращает:** {ok, Value}.</p><p>**Пример использования:**</p><p>{ok, Value} = fp\_db:read\_field(Object, Field).</p>|
|fp\_db:read\_field/3|<p>**:** Читает значение поля объекта с дополнительными параметрами.</p><p>**Возвращает:** {ok, Value}.</p><p>**Пример использования:**</p><p>{ok, Value} = fp\_db:read\_field(Object, Field, Params).</p>|
|fp\_db:read\_fields/2|<p>**:** Читает сразу несколько полей объекта.</p><p>**Возвращает:** Map с парами #{Field => Value}.</p><p>**Пример использования:**</p><p>Fields = fp\_db:read\_fields(Object, [field1, field2]).</p>|
|fp\_db:edit\_object/2|<p>**:** Изменяет значения полей объекта.</p><p>**Возвращает:** ok.</p><p>**Пример использования:**</p><p>ok = fp\_db:edit\_object(Object, #{field => value}).</p>|
|fp\_db:query/1|<p>**:** Выполняет запрос к хранилищу данных (Ecomet).</p><p>**Возвращает:** Результат запроса.</p><p>**Пример использования:**</p><p>Result = fp\_db:query(Query).</p>|

**Примечания**

- **RunTime:** Некоторые функции (fp:open\_tag, fp:get\_value, fp:set\_value) работают только в режиме RunTime.
- **Кеширование:** Функции fp оптимизированы за счёт использования кеша, что делает их быстрее аналогов из fp\_db.
- **Совместимость:** Архивные функции (fp:archives\_get, fp:archive\_get\_point) совместимы с функциями из fp\_archive.

  ## <a name="_heading=h.1pxezwc"></a>**Б.2 Модуль функций JavaScript (fp\_api\_js.md)**
  **Общая информация**

  fp\_api\_js предоставляет функции для взаимодействия с объектами SCADA-системы на базе JavaScript. Используйте функции для работы с тегами, хранилищем данных и архивами.

  **Общие рекомендации**

- **Асинхронность:** Все функции API возвращают промисы. Для получения результата используйте await.
- **Идентификаторы объектов:** Вместо путей к тегам можно использовать идентификаторы объектов, полученные при создании.

|**Функция**|**Описание**|
| :-: | :-: |
|**Работа с тегами**||
|fp.api.get\_value(path, field)|<p>: Получает значение заданного поля тега.</p><p>**Параметры:**</p><p>- path (string): Путь к тегу.</p><p>- field (string): Поле тега, значение которого необходимо получить.</p><p>&emsp;**Возвращает:**</p><p>- Значение поля.</p><p>&emsp;**Пример использования:**</p><p>&emsp;let value = await fp.api.get\_value('/root/PROJECT/TAGS/AI', 'value');</p>|
|fp.api.set\_value(path, field, value)|<p>: Устанавливает значение поля тега.</p><p>**Параметры:**</p><p>- path (string): Путь к тегу.</p><p>- field (string): Поле тега.</p><p>- value (any): Значение, которое нужно записать.</p><p>&emsp;**Возвращает:** undefined.</p><p>&emsp;**Пример использования:**</p><p>&emsp;fp.api.set\_value('/root/PROJECT/TAGS/AI', 'value', 10.5);</p>|
|fp.api.archives\_get(timestamps, archives)|<p>: Получает данные из архива для указанных временных точек.</p><p>**Параметры:**</p><p>- timestamps (array): Массив временных точек.</p><p>- archives (array): Массив массивов, где каждый элемент: [путь к архиву, агрегирующая функция].</p><p>&emsp;**Возвращает:**</p><p>- Массив массивов, содержащих временные метки и значения.</p><p>&emsp;**Пример использования:**</p><p>&emsp;let data = await fp.api.archives\_get(</p><p>&emsp;`    `[TS1, TS2, TS3],</p><p>&emsp;`    `[["/root/PROJECT/TAGS/archive\_1", "avg"]]</p><p>&emsp;);</p>|
|**Работа с хранилищем данных**||
|fp.db.create\_object(params)|<p>: Создает новый объект.</p><p>**Параметры:**</p><p>- params (object): Параметры объекта, включая .name, .folder, .pattern и дополнительные поля.</p><p>&emsp;**Возвращает:**</p><p>- Идентификатор созданного объекта.</p><p>&emsp;**Пример использования:**</p><p>&emsp;let obj = await fp.db.create\_object({</p><p>&emsp;`    `".name": "mytag",</p><p>&emsp;`    `".folder": "/root/PROJECT/TAGS/folder",</p><p>&emsp;`    `".pattern": "/root/.patterns/AI",</p><p>&emsp;`    `"value": 1.0</p><p>&emsp;});</p>|
|fp.db.read\_field(object, field)|<p>: Читает значение поля объекта.</p><p>**Параметры:**</p><p>- object (string | ID): Путь или идентификатор объекта.</p><p>&emsp;- field (string): Название поля.</p><p>&emsp;&emsp;**Возвращает:**</p><p>&emsp;- Значение поля.</p><p>&emsp;&emsp;**Пример использования:**</p><p>&emsp;&emsp;let value = await fp.db.read\_field('/root/PROJECT/TAGS/AI', 'value');</p>|
|fp.db.edit\_object(object, changes)|<p>: Редактирует существующий объект.</p><p>**Параметры:**</p><p>- object (string | ID): Путь или идентификатор объекта.</p><p>&emsp;- changes (object): Изменяемые поля и их новые значения.</p><p>&emsp;&emsp;**Возвращает:** undefined.</p><p>&emsp;&emsp;**Пример использования:**</p><p>&emsp;&emsp;fp.db.edit\_object('/root/PROJECT/TAGS/AI', { value: 1.0, title: "Updated" });</p>|
|fp.db.delete\_object(object)|<p>: Удаляет объект.</p><p>**Параметры:**</p><p>- object (string | ID): Путь или идентификатор объекта.</p><p>&emsp;&emsp;**Возвращает:** undefined.</p><p>&emsp;&emsp;**Пример использования:**</p><p>&emsp;&emsp;fp.db.delete\_object('/root/PROJECT/TAGS/AI');</p>|
|**Работа с транзакциями**||
|fp.db.start\_transaction()|<p>: Начинает транзакцию.</p><p>**Пример использования:**</p><p>fp.db.start\_transaction();</p>|
|fp.db.commit\_transaction()|<p>: Фиксирует транзакцию.</p><p>**Пример использования:**</p><p>fp.db.commit\_transaction();</p>|
|fp.db.rollback\_transaction()|<p>: Откатывает транзакцию.</p><p>**Пример использования:**</p><p>fp.db.rollback\_transaction();</p>|

**Примечание**

- Используйте функции API только в асинхронном контексте (async).
- Примерный список агрегирующих функций для работы с архивами: min, max, avg, sum, steps, categories.
- Некоторые функции (dirty\_edit\_object) работают быстрее за счет отсутствия проверок, но требуют повышенной осторожности.

  ## <a name="_heading=h.49x2ik5"></a>**Б.3 Модуль функций для работы с базой данных (fp\_sql.md)**
  **Общая информация**

  fp\_sql предоставляет инструменты для подключения к реляционным базам данных через ODBC, используя модуль odbc в Erlang.

  Этот механизм позволяет выполнять SQL-запросы к базам данных PostgreSQL, MSSQL и другим, поддерживающим ODBC-драйвера.

  Модуль можно использовать в пользовательских скриптах и консоли Erlang.

|**Функция**|**Описание**|
| :-: | :-: |
|odbc:start().|: Инициализирует модуль odbc. Это обязательный шаг перед использованием функций модуля.|
|{ok, Ref} = odbc:connect(ConnectionString, Options).|<p>: Подключает к базе данных.</p><p>**Параметры:**</p><p>- ConnectionString: строка подключения ODBC.</p><p>- Options: список параметров подключения.</p><p>&emsp;**Возвращает:**</p><p>- Кортеж {ok, Ref} — успешное подключение, где Ref — ссылка на соединение.</p><p>- error — если подключение не удалось.</p><p>&emsp;**Пример использования:**</p><p>&emsp;erlang</p><p>&emsp;Копировать код{ok, Ref} = odbc:connect(</p><p>&emsp;`    `"Driver={/usr/lib/x86\_64-linux-gnu/odbc/psqlodbca.so};Server=192.168.2.158;Port=5432;Database=BZ2;Uid=postgres;Pwd=2312;",</p><p>&emsp;`    `[]</p><p>&emsp;).</p>|
|Result = odbc:sql\_query(Ref, SQLQuery).|<p>: Выполняет SQL-запрос.</p><p>**Параметры:**</p><p>- Ref: ссылка на соединение.</p><p>- SQLQuery: строка с SQL-запросом.</p><p>&emsp;**Возвращает:**</p><p>- Результаты выполнения SQL-запроса.</p><p>&emsp;**Пример использования:**</p><p>&emsp;Result = odbc:sql\_query(Ref, "SELECT \* FROM table").</p>|
|odbc:disconnect(Ref).|<p>: Закрывает соединение с базой данных.</p><p>**Параметры:**</p><p>- Ref: ссылка на соединение.</p><p>&emsp;**Пример использования:**</p><p>&emsp;odbc:disconnect(Ref).</p>|
|odbc:stop().|<p>: Завершает работу модуля odbc.</p><p>**Пример использования:**</p><p>odbc:stop().</p>|

**Примеры использования**

**Пример подключения к PostgreSQL**

odbc:start().

{ok, Ref} = odbc:connect(

`    `"Driver={/usr/lib/x86\_64-linux-gnu/odbc/psqlodbca.so};Server=192.168.2.158;Port=5432;Database=BZ2;Uid=postgres;Pwd=2312;",

`    `[]

).

Result = odbc:sql\_query(Ref, "SELECT \* FROM table").

odbc:disconnect(Ref).

odbc:stop().

**Пример подключения к MSSQL**

odbc:start().

{ok, Ref} = odbc:connect(

`    `"Driver=/usr/lib/x86\_64-linux-gnu/odbc/libtdsodbc.so;Server=192.168.210.172,1433;Database=remont;Uid=wacs;Pwd=wacs;",

`    `[]

).

Result = odbc:sql\_query(Ref, "SELECT \* FROM remont.utpo.r\_ORZ").

odbc:disconnect(Ref).

odbc:stop().

**Примечания**

- **Подготовка системы:** Для работы с ODBC необходимо установить драйверы:

  *PostgreSQL:*

  sudo apt-get install unixodbc odbc-postgresql

  *MSSQL:*

  sudo apt-get install unixodbc tdsodbc

- **Кодировки MSSQL:** В некоторых случаях требуется указать параметр use\_unicode=true в строке подключения, чтобы избежать проблем с кодировкой:

  {ok, Ref} = odbc:connect(

  `    `"Driver=/usr/lib/x86\_64-linux-gnu/odbc/libtdsodbc.so;Server=192.168.210.172,1433;Database=remont;Uid=wacs;Pwd=wacs;use\_unicode=true",

  `    `[]

  ).

- **Пути драйверов:** Проверьте, что драйверы установлены в правильных папках:

  /usr/lib/x86\_64-linux-gnu/odbc/

  /opt/microsoft/msodbcsql17/lib64/

- **Официальная документация и справка:**

  https://docs.microsoft.com/en-us/sql/connect/odbc/

  https://www.connectionstrings.com/

  # <a name="_heading=h.2p2csry"></a>**Приложение В. Модуль функций для работы с журналами**
  Система журналирования предоставляет два API для взаимодействия с платформой:

- REST API для базовых операций, таких как проверка работоспособности и простые запросы к журналам.
- WebSocket API для функций реального времени и более сложных операций.
  ## <a name="_heading=h.147n2zr"></a>**В.1 REST API**
  Базовый URL: https://bpm.example.com/api/v1

  Эндпоинты API:

1. **/journals** - Работа с журналами
1. **/dictionaries** - Получение списка справочников
1. **/dictionary/{name}** - Получение данных конкретного справочника
1. **/query** - Выполнение SQL-запросов
1. **/ws** - WebSocket подключение

   Все ответы возвращаются в формате JSON:

   {

   `    `"success": boolean,

   `    `"data": array,     // Массив данных при успехе

   `    `"errors": [        // Массив ошибок при неудаче

   `        `{

   `            `"code": number,

   `            `"message": string

   `        `}

   `    `]

   }

   *Проверка работоспособности:*

   GET /health - проверяет состояние работоспособности API.

   Коды ответов:

- 200: Сервис работает
- 500: Ошибка сервера

  GET /journals** - получение записей журнала по заданным параметрам.

  Параметры запроса:

- name (обязательный): Идентификатор типа журнала
- fields (опционально): Массив запрашиваемых полей
- rdc (опционально): Путь к региональному диспетчерскому центру
- from (опционально): Начальная временная метка (Unix в мс)
- to (опционально): Конечная временная метка (Unix в мс)

  POST /journals** - создание новой записи в журнале.

  Обязательные поля:

  {

  `    `"name": "string",        // Тип журнала

  `    `".folder": "string",     // OID путь к папке

  `    `".pattern": "string",    // OID путь к шаблону

  `    `// Дополнительные поля в зависимости от типа журнала

  }

  Стандартные ответы с ошибками:

  {

  `    `"success": false,

  `    `"errors": [{

  `        `"code": 400,

  `        `"message": "Некорректный JSON"

  `    `}]

  }

  Коды ошибок:

- 400: Некорректный запрос (неверные параметры/JSON)
- 404: Журнал не найден
- 500: Ошибка сервера

  ## <a name="_heading=h.3o7alnk"></a>**В.2 WebSocket API**

  Подключение - WebSocket endpoint: ws://{host}:{port}/websocket

  Для WebSocket соединений требуется аутентификация. Можно использовать метод login:

  {

  `    `"id": "1",

  `    `"action": "login",

  `    `"params": {

  `        `"login": "username",

  `        `"password": "password"

  `    `}

  }

  Формат запроса:

  {

  `    `"id": string,           // Идентификатор запроса

  `    `"action": string,       // Название метода

  `    `"params": object        // Параметры метода

  }

  Формат ответа:

  {

  `    `"id": string,           // Тот же ID что и в запросе

  `    `"type": "ok"|"error",   // Тип ответа

  `    `"result": any          // Данные ответа или сообщение об ошибке

  }

  ### <a name="_heading=h.5wtu4hvuijos"></a>**В.2.1 Основные функции WebSocket API**

  |**Функция**|**Описание**|
    | :-: | :-: |
  |**Системные методы**||
  |get\_server\_time()|<p>Получение текущего времени сервера</p><p>Параметры: нет</p><p>Возвращает: строка с временем в формате RFC3339</p>|
  |get\_unit()|<p>Получение информации о текущем диспетчерском центре</p><p>Параметры: нет</p><p>Возвращает:</p><p> </p><p>{</p><p>`    `"unit\_type": "ndc|rdc",  // Тип центра (НДЦ/РДЦ)</p><p>`    `"name": "string"         // Название центра</p><p>**}**</p>|
  |get\_version()|<p>Получение версии приложения</p><p>Параметры: нет</p><p>Возвращает: строка с версией</p>|
  |get\_status()|<p>Получение статуса системы</p><p>Параметры: нет</p><p>Возвращает: статус системы</p>|
  |**Функции запросов**||
  |ecomet\_query|<p>Универсальная функция для выполнения запросов</p><p>Автоматически определяет локальное или удаленное выполнение на основе типа центра</p><p>Параметры:</p><p> </p><p>{</p><p>`    `"action": "string",        // Действие</p><p>`    `"params": object,          // Параметры запроса</p><p>`    `"connection\_type": "local|remote"  // Тип подключения (для РДЦ)</p><p>}</p>|
  |local\_query|<p>Выполнение локального запроса</p><p>Параметры:</p><p>{</p><p>`    `"action": "string",  // Действие</p><p>`    `"params": object    // Параметры запроса</p><p>}</p>|
  |remote\_query|<p>Выполнение удаленного запроса (доступно только для РДЦ)</p><p>Параметры: аналогичны local\_query</p>|



**Особенности работы:**

1\. Маршрутизация запросов:

·                     В НДЦ все запросы выполняются локально

·                     В РДЦ запросы могут выполняться как локально, так и удаленно

2\. Мониторинг производительности:

·                     Система логирует запросы, выполняющиеся более 1 секунды

·                     Отслеживается размер ответов

3\. Обработка ошибок:

·                     При ошибках подключения возвращается соответствующий статус

·                     При некорректных параметрах возвращается описание ошибки



**Примеры запросов:**

1\. Получение информации о центре:

{

`    `"id": "1",

`    `"action": "get\_unit"

}



2\. Выполнение локального запроса:

{

`    `"id": "2",

`    `"action": "local\_query",

`    `"params": {

`        `"action": "query\_action",

`        `"params": {

`            `// Параметры запроса

`        `}

`    `}

}



3\. Выполнение запроса с автоматической маршрутизацией:

{

`    `"id": "3",

`    `"action": "ecomet\_query",

`    `"params": {

`        `"action": "query\_action",

`        `"params": {

`            `// Параметры запроса

`        `},

`        `"connection\_type": "remote"  // или "local"

`    `}

}


## <a name="_heading=h.ihv636"></a>**В.3 API Справочников (WebSocket)**
API справочников доступно через WebSocket соединение. Для получения данных из справочников используется метод "application" с модулем "bpm\_dictionaries".

**Базовый формат запроса:**

{

`    `"id": "1",

`    `"action": "application",

`    `"params": {

`        `"module": "bpm\_dictionaries",

`        `"function": "get\_dictionary",

`        `"function\_params": {

`            `"name": "имя\_справочника",

`            `// Дополнительные параметры фильтрации

`        `}

`    `}

}

**Доступные справочники и методы**

1\. Справочники объектов:

- i\_obj - Информация об объектах

  {

  `    `"name": "i\_obj",

  `    `"cod\_en": "01",  // Код энергообъекта

  `    `"cod\_obj": "10"  // Код объекта

  }

  2\. Справочники линий:

- r\_vlo - Информация о ВЛ

  {

  `    `"name": "r\_vlo",

  `    `"cod\_en": "01",

  `    `"ot\_PrVl": "Р"  // Тип ВЛ (Р-региональная, М-межрегиональная)

  }

  3\. Справочники устройств:

- devices - Информация об устройствах

  {

  `    `"name": "devices",

  `    `"cod": "01"

  }

  4\. Справочники оборудования:

- r\_tools - Информация об инструментах

  {

  `    `"name": "r\_tools",

  `    `"cod\_obj": "01",

  `    `"cod\_en": "01"

  }

  5\. Другие справочники:

- i\_mes - Информация МЭС
- i\_vidobor - Типы оборудования
- r\_asdu - Данные АСДУ
- r\_eto - Данные ЭТО
- r\_otto - Данные ОТТО
- r\_rza - Данные РЗА
- r\_tms - Данные ТМС
- r\_vtto - Данные ВТТО
- i\_energo - Энергообъекты

  **Примеры запросов:**

1. Получение данных об объекте:

   {

   `    `"id": "1",

   `    `"action": "application",

   `    `"params": {

   `        `"module": "bpm\_dictionaries",

   `        `"function": "get\_dictionary",

   `        `"function\_params": {

   `            `"name": "i\_obj",

   `            `"cod\_en": "01",

   `            `"cod\_obj": "10"

   `        `}

   `    `}

   }

   2\. Получение данных о ВЛ:

   {

   `    `"id": "2",

   `    `"action": "application",

   `    `"params": {

   `        `"module": "bpm\_dictionaries",

   `        `"function": "get\_dictionary",

   `        `"function\_params": {

   `            `"name": "r\_vlo",

   `            `"cod\_en": "01",

   `            `"ot\_PrVl": "Р"

   `        `}

   `    `}

   }

   3\. Получение списка устройств:

   {

   `    `"id": "3",

   `    `"action": "application",

   `    `"params": {

   `        `"module": "bpm\_dictionaries",

   `        `"function": "get\_dictionary",

   `        `"function\_params": {

   `            `"name": "devices",

   `            `"cod": "01"

   `        `}

   `    `}

   }

   **Особенности работы с API справочников:**

1. Кодировка данных:
- Все текстовые данные должны быть в UTF-8
- При необходимости происходит автоматическая конвертация из CP1251

2\. Обработка ошибок:

- При отсутствии данных возвращается пустой массив
- При ошибках в параметрах возвращается сообщение об ошибке
- При ошибках подключения к хранилищу данных происходит автоматическая попытка переподключения

3\. Рекомендации:

- Рекомендуется кэшировать редко изменяемые справочники
- Для больших справочников используйте фильтрацию
- Следите за форматом кодов в параметрах фильтрации

  **Поддерживаемые типы журналов:**

|**Тип журнала**|**Шаблон**|**Описание**|
| :-: | :-: | :-: |
|SAON|/root/.patterns/saon\_item|Журнал САОН|
|ORDERS\_RZA|/root/.patterns/order\_rza|Журнал распоряжений РЗА|
|ORDERS|/root/.patterns/order|Общие распоряжения|
|REMARK\_ASDU|/root/.patterns/remark\_asdu|Журнал замечаний АСДУ|
|RESTRICTION\_ENTRY|/root/.patterns/restriction\_entry|Журнал ограничений|
|ACCIDENTS|/root/.patterns/accident\_report|Журнал несчастных случаев|
|FIRES|/root/.patterns/fire\_report|Журнал пожаров|
|OPER\_MESSAGE|/root/.patterns/oper\_message\_object|Оперативные сообщения|
|OPER\_REPORT|/root/.patterns/oper\_report|Оперативные донесения|

**Примеры**

1. Запрос к справочнику через WebSocket:

{

`    `"id": "1",

`    `"action": "application",

`    `"params": {

`        `"module": "bpm\_dictionaries",

`        `"function": "get\_dictionary",

`        `"function\_params": {

`            `"name": "i\_obj",

`            `"cod\_en": "01",

`            `"cod\_obj": "10"

`        `}

`    `}

}

1. Создание записи в журнале:

{

`    `"id": "2",

`    `"action": "create",

`    `"params": {

`        `"name": "ORDERS",

`        `".folder": "/root/JOURNALS/ORDERS",

`        `".pattern": "/root/.patterns/order",

`        `"theme": "Тестовая запись распоряжения",

`        `"message": "Детали распоряжения"

`    `}

}

1. Запрос записей журнала:

{

`    `"id": "3", 

`    `"action": "query",

`    `"params": {

`        `"pattern": "/root/.patterns/order",

`        `"fields": ["theme", "message", "created\_at"],

`        `"filter": {

`            `".folder": "/root/JOURNALS/ORDERS"

`        `}

`    `}

}

**Примечания**

- Все даты передаются в формате Unix timestamp в миллисекундах.
- При работе с WebSocket API важно сначала выполнить аутентификацию.
- Для больших объемов данных рекомендуется использовать постраничную загрузку.
- При работе со справочниками рекомендуется кэшировать редко изменяемые данные.
- Все текстовые данные должны быть в кодировке UTF-8.

  **Безопасность**

- Используйте HTTPS для REST API в продакшн среде.
- Храните токены аутентификации в безопасном месте.
- Не передавайте конфиденциальные данные в URL параметрах.
- Используйте таймауты для WebSocket соединений.
- Регулярно обновляйте учетные данные пользователей.

  # <a name="_heading=h.5tkvgb526w1h"></a>**Приложение Г. Функции модуля прогнозирования**
  ## <a name="_heading=h.wcspsdibp3zg"></a>**Г.1 Модуль preprocess.py**
  **Общая информация**

  Модуль preprocess.py предназначен

  для предобработки данных о потреблении и генерации электроэнергии. Он включает

  в себя функции для очистки данных, объединения с метеорологическими и

  ремонтными данными, удаления выбросов и подготовки данных для последующего

  анализа. Основные компоненты модуля:

  ·                     Чтение и обработка входных данных.

  ·                     Объединение с погодными и ремонтными данными.

  ·                     Обработка выбросов.

  ·                     Преобразование в формат Faceplate при необходимости.

  ·                     Сохранение данных в csv и генерация графиков в pdf.



|**Функция**|**Описание**|
  | :-: | :-: |
|parse\_args()|<p>:** Парсит аргументы командной строки,</p><p>`  `определяя пути к файлам данных, флаг генерации и настройки обработки</p><p>`  `выбросов.</p><p>**Параметры:**</p><p>·                     Нет параметров.</p><p>**Возвращает:**</p><p>·                     argparse.Namespace – объект с аргументами командной строки.</p><p>**Пример использования:**</p><p>args = parse\_args()</p><p>print(args.data\_filepath)</p><p>**Детали реализации:**</p><p>Использует argparse.ArgumentParser, чтобы определить аргументы, включая пути к файлам данных и настройки обработки.</p>|
|<p>add\_day\_offs(df:</p><p>`  `pd.DataFrame) -> pd.DataFrame</p>|<p>:** Добавляет в DataFrame информацию о выходных и праздничных днях.</p><p>**Параметры:**</p><p>·                     df (pd.DataFrame) – входные данные с колонкой dt (дата-время).</p><p>**Возвращает:**</p><p>·                     pd.DataFrame – DataFrame с новыми колонками:</p><p>o                  weekday – день недели.</p><p>o                  is\_holiday – флаг, является ли день праздником.</p><p>o                  is\_forced\_non\_holiday – флаг принудительно не праздничного дня.</p><p>o                  is\_day\_off – флаг выходного дня.</p><p>**Пример использования:**</p><p>df = add\_day\_offs(df)</p><p>**Детали реализации:**</p><p>Использует списки праздников HOLIDAYS\_2019-2023 и FORCE\_NON\_HOLIDAYS\_2019-2023, а также столбец dt для определения выходных.</p>|
|merge\_weather\_data(df: pd.DataFrame, weather\_data\_dirpath: Path) -> pd.DataFrame|<p>:** Объединяет входные данные с метеорологическими данными.</p><p>**Параметры:**</p><p>·                     df (pd.DataFrame) – входные данные.</p><p>·                     weather\_data\_dirpath (Path) – путь к директории с метеоданными.</p><p>**Возвращает:**</p><p>·                     pd.DataFrame – DataFrame с добавленными температурами по регионам.</p><p>**Пример использования:**</p><p>df = merge\_weather\_data(df, Path('weather\_data'))</p><p>**Детали реализации:**</p><p>Читает файлы с температурой, преобразует их и объединяет с df по времени.</p>|
|merge\_rz\_data(df: pd.DataFrame, rz\_data\_dirpath: Path, filter\_24h=True) -> pd.DataFrame|<p>:** Объединяет входные данные с данными о ремонтных зонах.</p><p>**Параметры:**</p><p>·                     df (pd.DataFrame) – входные данные.</p><p>·                     rz\_data\_dirpath (Path) – путь к директории с данными о ремонтных зонах.</p><p>·                     filter\_24h (bool, по умолчанию True) – фильтровать данные на сутки вперед.</p><p>**Возвращает:**</p><p>·                     pd.DataFrame – DataFrame с добавленными данными о ремонтах.</p><p>**Пример использования:**</p><p>df = merge\_rz\_data(df, Path('rz\_data'))</p><p>**Детали реализации:**</p><p>Читает ремонтные данные, агрегирует их и объединяет с df по временным меткам.</p>|
|strip\_colnames(df: pd.DataFrame) -> pd.DataFrame|<p>:** Удаляет лишние пробелы из названий колонок.</p><p>**Параметры:**</p><p>·                     df (pd.DataFrame) – входные данные.</p><p>**Возвращает:**</p><p>·                     pd.DataFrame – DataFrame с обновленными именами колонок.</p><p>**Пример использования:**</p><p>df = strip\_colnames(df)</p><p>**Детали реализации:**</p><p>Использует rename() и strip() для очистки названий колонок.</p>|
|clean\_outliers(df: pd.DataFrame, outlier\_neighbor\_threshold=100.0, method='running\_mean', ...) -> pd.DataFrame|<p>:** Удаляет выбросы в данных.</p><p>**Параметры:**</p><p>·                     df (pd.DataFrame) – входные данные.</p><p>·                     outlier\_neighbor\_threshold (float, по умолчанию 100.0) – порог для выбросов.</p><p>·                     method (Literal['diff', 'diff\_twosided', 'running\_mean'] | None, по умолчанию 'running\_mean') – метод очистки.</p><p>**Возвращает:**</p><p>·                     pd.DataFrame – очищенный DataFrame.</p><p>**Пример использования:**</p><p>df = clean\_outliers(df, method='diff')</p><p>**Детали реализации:**</p><p>Использует методы diff, diff\_twosided, running\_mean для удаления выбросов.</p>|
|preprocess(df: pd.DataFrame, weather\_data\_dirpath: Path, rz\_data\_dirpath: Path, ...) -> pd.DataFrame|<p>:** Основная функция предобработки данных.</p><p>**Параметры:**</p><p>·                     df (pd.DataFrame) – входные данные.</p><p>·                     weather\_data\_dirpath (Path) – путь к метеоданным.</p><p>·                     rz\_data\_dirpath (Path) – путь к ремонтным данным.</p><p>**Возвращает:**</p><p>·                     pd.DataFrame – обработанный DataFrame.</p><p>**Пример использования:**</p><p>df = preprocess(df, Path('weather\_data'), Path('rz\_data'))</p><p>**Детали реализации:**</p><p>Объединяет все предыдущие этапы: очистку, объединение, удаление выбросов.</p>|
|main(args)|<p>:** Основная функция обработки данных.</p><p>**Параметры:**</p><p>·                     args (argparse.Namespace) – аргументы командной строки.</p><p>**Возвращает:**</p><p>·                     pd.DataFrame – итоговый DataFrame.</p><p>**Пример использования:**</p><p>if \_\_name\_\_ == '\_\_main\_\_':</p><p>`    `args = parse\_args()</p><p>`    `main(args)</p><p>**Детали реализации:**</p><p>Считывает входные данные, обрабатывает их и сохраняет в csv и pdf.</p>|


## <a name="_heading=h.fklm5w6xfb1i"></a>**Г.2 Модуль train.py**
**Общая информация**

Модуль train.py предназначен для обучения модели машинного обучения (XGBoost, Decision Tree, MLP) на данных потребления электроэнергии. Он включает в себя:

·                     Парсинг аргументов командной строки.

·                     Предобработку данных.

·                     Обучение модели.

·                     Оценку качества предсказаний.

·                     Сохранение обученной модели и отчётов.

|**Функция**|**Описание**|
  | :-: | :-: |
|parse\_args()|<p>:** Парсит аргументы командной строки,</p><p>`  `задающие параметры обучения, пути к данным и конфигурации модели.</p><p>**Параметры:**</p><p>·                     Нет.</p><p>**Возвращает:**</p><p>·                     argparse.Namespace – объект с аргументами командной строки.</p><p>**Пример использования:**</p><p>args = parse\_args()</p><p>print(args.data\_filepath)</p><p>**Детали реализации:**</p><p>Использует argparse.ArgumentParser для определения аргументов, включая путь к данным, параметры модели и настройки обработки.</p>|
|<p>build\_normalization(region\_col:</p><p>`  `str, sub: pd.Series, div: pd.Series, month\_mean: Dict[str, Dict[int, float]])</p><p>`  `-> Dict</p>|<p>:** Создаёт структуру нормализации данных для конкретного региона.</p><p>**Параметры:**</p><p>·                     region\_col (str) – название столбца региона.</p><p>·                     sub (pd.Series) – значения для центрирования данных.</p><p>·                     div (pd.Series) – значения для масштабирования данных.</p><p>·                     month\_mean (Dict[str, Dict[int, float]]) – средние значения потребления по месяцам.</p><p>**Возвращает:**</p><p>·                     dict – структура нормализации.</p><p>**Пример использования:**</p><p>normalization = build\_normalization('Р потр. АлмО', sub, div, month\_mean)</p><p>**Детали реализации:**</p><p>Отбирает ключевые столбцы и переименовывает их в стандартные имена.</p>|
|main(args)|<p>:** Основная функция обучения модели. Выполняет:</p><p>1\.                 Инициализацию случайного зерна (seed\_everything).</p><p>2\.                 Подготовку данных (prepare\_data).</p><p>3\.                 Обучение модели (fit\_shortterm).</p><p>4\.                 Оценку модели (evaluate).</p><p>5\.                 Сохранение модели и отчётов.</p><p>**Параметры:**</p><p>·                     args (argparse.Namespace) – аргументы командной строки.</p><p>**Возвращает:**</p><p>·                     None.</p><p>**Пример использования:**</p><p>if \_\_name\_\_ == '\_\_main\_\_':</p><p>`    `args = parse\_args()</p><p>`    `main(args)</p><p>**Детали реализации:**</p><p>1\.                 Проверяет корректность аргументов.</p><p>2\.                 Загружает данные.</p><p>3\.                 Обрабатывает их в нужном формате.</p><p>4\.                 Обучает модель на каждом регионе отдельно.</p><p>5\.                 Сохраняет обученные модели и отчёты.</p>|


## <a name="_heading=h.e18hfxe2fscc"></a>**Г.3 Модуль gridsearch.py**
**Общая информация**

Модуль gridsearch.py предназначен для выполнения подбора гиперпараметров (Grid Search) модели XGBoost или Decision Tree при предсказании потребления электроэнергии. Он включает в себя:

·                     Парсинг аргументов командной строки.

·                     Загрузку данных.

·                     Генерацию комбинаций гиперпараметров.

·                     Обучение моделей с различными параметрами.

·                     Оценку качества моделей.

·                     Сохранение метрик и визуализацию результатов.

|**Функция**|**Описание**|
  | :-: | :-: |
|parse\_args()|<p>: Парсит аргументы командной строки,</p><p>`  `задающие параметры для Grid Search.</p><p>**Параметры:**</p><p>·                     Нет.</p><p>**Возвращает:**</p><p>·                     argparse.Namespace – объект с аргументами командной строки.</p><p>**Пример использования:**</p><p>args = parse\_args()</p><p>print(args.gridsearch\_config\_filepath)</p><p>**Детали реализации:**</p><p>Использует argparse.ArgumentParser для задания параметров, включая пути к данным, параметры модели и настройки перебора гиперпараметров.</p>|
|prepare\_gridsearch(args)|<p>: Подготавливает данные для выполнения Grid Search.</p><p>**Параметры:**</p><p>·                     args (argparse.Namespace) – аргументы командной строки.</p><p>**Возвращает:**</p><p>·                     tuple – кортеж из:</p><p>o                  gridsearch\_product (list[dict]) – список комбинаций гиперпараметров.</p><p>o                  base\_model\_kwargs (dict) – базовые параметры модели.</p><p>o                  df\_train, df\_val, df\_test (pd.DataFrame) – обучающие, валидационные и тестовые данные.</p><p>o                  sub, div, month\_mean (dict) – данные для нормализации.</p><p>**Пример использования:**</p><p>gridsearch\_product, base\_model\_kwargs, df\_train, df\_val, df\_test, sub, div, month\_mean = prepare\_gridsearch(args)</p><p>**Детали реализации:**</p><p>1\.                 Проверяет существование файлов конфигурации.</p><p>2\.                 Создаёт директорию для сохранения результатов.</p><p>3\.                 Загружает данные (prepare\_data).</p><p>4\.                 Загружает параметры модели из base\_model\_config\_filepath.</p><p>5\.                 Генерирует список комбинаций параметров (product\_dict).</p><p>6\.                 Добавляет поддержку GPU, если необходимо.</p>|
|main(args)|<p>: Основная функция выполнения Grid Search. Она:</p><p>1\.                 Подготавливает данные (prepare\_gridsearch).</p><p>2\.                 Перебирает комбинации параметров и обучает модель (fit\_shortterm).</p><p>3\.                 Оценивает модель (evaluate).</p><p>4\.                 Сохраняет метрики (metrics.csv).</p><p>5\.                 Визуализирует результаты (metrics.html).</p><p>**Параметры:**</p><p>·                     args (argparse.Namespace) – аргументы командной строки.</p><p>**Возвращает:**</p><p>·                     None.</p><p>**Пример использования:**</p><p>if \_\_name\_\_ == '\_\_main\_\_':</p><p>`    `args = parse\_args()</p><p>`    `main(args)</p><p>**Детали реализации:**</p><p>1\.                 Загружает данные.</p><p>2\.                 Для каждого набора параметров обучает модель и оценивает её.</p><p>3\.                 Записывает метрики и гиперпараметры.</p><p>4\.                 Создаёт интерактивный график parallel\_coordinates для анализа влияния параметров.</p>|


## <a name="_heading=h.e2r3t8f25f3c"></a>**Г.4 Модуль utils.py**
**Общая информация**

Модуль utils.py содержит вспомогательные функции для работы с данными потребления электроэнергии. Он включает в себя:

·                     Чтение данных и их предварительную обработку.

·                     Разделение данных на обучающий, валидационный и тестовый наборы.

·                     Формирование выборок признаков и целевых значений.

·                     Нормализацию данных.

|**Функция**|**Описание**|
  | :-: | :-: |
|<p>read\_data(data\_filepath:</p><p>`  `Path, drop\_2023='rows') -> pd.DataFrame</p>|<p>: Читает данные из CSV-файла,</p><p>`  `добавляет временные признаки и обрабатывает пропущенные значения.</p><p>**Параметры:**</p><p>·                     data\_filepath (Path) – путь к файлу с данными.</p><p>·                     drop\_2023 (str, по умолчанию 'rows') – способ обработки данных за 2023 год:</p><p>o                  'rows' – удалить строки 2023 года.</p><p>o                  'cols' – удалить столбцы, отсутствующие в 2023 году.</p><p>**Возвращает:**</p><p>·                     pd.DataFrame – обработанный DataFrame.</p><p>**Пример использования:**</p><p>df = read\_data(Path('data.csv'))</p><p>**Детали реализации:**</p><p>1\.                 Читает CSV-файл.</p><p>2\.                 Конвертирует дату-время.</p><p>3\.                 Добавляет признаки выходных и праздничных дней.</p><p>4\.                 Добавляет географические координаты.</p><p>5\.                 Удаляет строки или столбцы 2023 года в зависимости от аргумента drop\_2023.</p><p>6\.                 Заполняет пропущенные значения методом ffill().</p>|
|<p>split\_train\_val\_test(</p><p>`    `df: pd.DataFrame,</p><p>`    `test: Literal['2022', '2023'] | None = '2022',</p><p>`    `use\_val: bool = True,</p><p>) -> Tuple[pd.DataFrame, pd.DataFrame | None, pd.DataFrame]</p>|<p>: Разделяет данные на обучающую, валидационную и тестовую выборки.</p><p>**Параметры:**</p><p>·                     df (pd.DataFrame) – входные данные.</p><p>·                     test (str | None, по умолчанию '2022') – год, который будет использоваться как тестовый ('2022' или '2023').</p><p>·                     use\_val (bool, по умолчанию True) – использовать ли валидационную выборку.</p><p>**Возвращает:**</p><p>·                     Tuple[pd.DataFrame, pd.DataFrame | None, pd.DataFrame] – кортеж с обучающей, валидационной и тестовой выборками.</p><p>**Пример использования:**</p><p>df\_train, df\_val, df\_test = split\_train\_val\_test(df, test='2023', use\_val=True)</p><p>**Детали реализации:**</p><p>1\.                 Если test='2022', то:</p><p>o                  2022 – тестовые данные.</p><p>o                  2021 – валидационные (если use\_val=True).</p><p>o                  Остальные данные – обучающие.</p><p>2\.                 Если test='2023', то аналогично, но сдвиг на год вперёд.</p><p>3\.                 Если test=None, то 80% данных – обучающие, 10% – валидационные, 10% – тестовые.</p>|
|<p>get\_X\_y\_dt(</p><p>`    `df,</p><p>`    `region\_col=None,</p><p>`    `stride=1,</p><p>`    `n\_history=144,</p><p>`    `n\_skip=1,</p><p>`    `n\_predict\_steps=144,</p><p>`    `features\_mode='future',</p><p>`    `aug\_ampl\_percent=None,</p><p>`    `lowres=None,</p><p>`    `add\_remont\_data=False,</p><p>)</p>|<p>: Формирует матрицу признаков X, целевую переменную y и временные метки dt для обучения модели.</p><p>**Параметры:**</p><p>·                     df (pd.DataFrame) – входные данные.</p><p>·                     region\_col (str | None) – название столбца региона.</p><p>·                     stride (int, по умолчанию 1) – шаг скользящего окна.</p><p>·                     n\_history (int, по умолчанию 144) – количество временных шагов в истории.</p><p>·                     n\_skip (int, по умолчанию 1) – пропуск временных шагов перед прогнозом.</p><p>·                     n\_predict\_steps (int, по умолчанию 144) – количество шагов предсказания.</p><p>·                     features\_mode (str, по умолчанию 'future') – режим генерации признаков ('history', 'future\_wide', 'future').</p><p>·                     aug\_ampl\_percent (int | None) – процент случайного масштабирования данных (аугментация).</p><p>·                     lowres (str | None) – использовать ли низкое разрешение ('hours' или 'days').</p><p>·                     add\_remont\_data (bool, по умолчанию False) – учитывать ли ремонтные данные.</p><p>**Возвращает:**</p><p>·                     Tuple[np.ndarray, np.ndarray, np.ndarray] – (X, y, dt).</p><p>**Пример использования:**</p><p>X, y, dt = get\_X\_y\_dt(df, region\_col='Р потр. АлмО', n\_history=72, n\_predict\_steps=72)</p><p>**Детали реализации:**</p><p>1\.                 Определяет используемые признаки (погодные, временные, категориальные).</p><p>2\.                 Создаёт временные последовательности с помощью np.lib.stride\_tricks.sliding\_window\_view().</p><p>3\.                 Поддерживает снижение разрешения (lowres).</p><p>4\.                 Генерирует аугментированные данные (aug\_ampl\_percent).</p><p>5\.                 Формирует X, y, dt.</p>|
|<p>prepare\_data(</p><p>`    `data\_filepath,</p><p>`    `test\_year,</p><p>`    `no\_val,</p><p>`    `debug,</p><p>`    `n\_shift\_numerical=None</p><p>)</p>|<p>: Полный цикл подготовки данных для обучения модели.</p><p>**Параметры:**</p><p>·                     data\_filepath (Path) – путь к файлу с данными.</p><p>·                     test\_year (str | None) – тестовый год ('2022' или '2023').</p><p>·                     no\_val (bool) – использовать ли валидацию.</p><p>·                     debug (bool) – использовать ли уменьшенный набор данных.</p><p>·                     n\_shift\_numerical (int | None) – сдвиг числовых данных.</p><p>**Возвращает:**</p><p>·                     Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame, dict, dict, dict] – обучающая, валидационная и тестовая выборки, параметры нормализации.</p><p>**Пример использования:**</p><p>df\_train, df\_val, df\_test, sub, div, month\_mean = prepare\_data(Path('data.csv'), test\_year='2023', no\_val=False, debug=False)</p><p>**Детали реализации:**</p><p>1\.                 Читает данные с обработкой (read\_data).</p><p>2\.                 Сдвигает числовые признаки (n\_shift\_numerical).</p><p>3\.                 Разделяет на обучающую, валидационную и тестовую выборки (split\_train\_val\_test).</p><p>4\.                 Нормализует данные (normalize).</p><p>5\.                 Вычисляет средние значения по месяцам.</p><p>6\.                 Если debug=True, оставляет только последние 1000 записей.</p>|


## <a name="_heading=h.w0b5omxolhj2"></a>**Г.4 Модуль constants.py**
**Общая информация**

Модуль constants.py содержит глобальные константы, используемые в других модулях проекта. Эти константы включают:

·                     Списки регионов, используемых в анализе.

·                     Даты праздников.

·                     Координаты регионов.

·                     Настройки очистки данных.

·                     Гиперпараметры для моделей.

Этот модуль не содержит функций, но служит важным компонентом для унифицированного управления параметрами.



|**Константа**|**Описание**|
  | :-: | :-: |
|REGION\_COLS|<p>:** Список столбцов с данными о</p><p>`  `потреблении электроэнергии по регионам.</p><p>**Пример использования:**</p><p>for region in REGION\_COLS:</p><p>`	`print(region)</p>|
|HOLIDAYS\_<YEAR>|<p>:** Списки праздничных дней для 2019–2023 годов. Используются для определения выходных и анализа сезонности.</p><p>**Пример использования:**</p><p>all\_holidays = HOLIDAYS\_2019 + HOLIDAYS\_2020 + HOLIDAYS\_2021</p>|
|REGION\_TO\_COORDS|<p>:** Словарь, сопоставляющий названия регионов с их географическими координатами.</p><p>**Пример использования:**</p><p>lat, lon = REGION\_TO\_COORDS['Р потр. АлмО']</p><p>print(f'Координаты: {lat}, {lon}')</p>|
|NO\_2023\_DATA\_COLS|<p>: Список столбцов, для которых нет данных за 2023 год. Используется для корректной обработки данных.</p><p>**Пример использования:**</p><p>df = df.drop(NO\_2023\_DATA\_COLS, axis=1)</p>|
|REGION\_TO\_XGB\_N\_ESTIMATORS|<p>: Словарь, содержащий оптимальное количество деревьев (n\_estimators) для модели XGBoost для каждого региона.</p><p>**Пример использования:**</p><p>n\_estimators = REGION\_TO\_XGB\_N\_ESTIMATORS.get('Р потр. АлмО', 100)</p>|



[ref1]: Aspose.Words.9ae2a643-68c3-4dd2-91ef-5048a0c23abe.001.png
[ref2]: Aspose.Words.9ae2a643-68c3-4dd2-91ef-5048a0c23abe.008.png
[ref3]: Aspose.Words.9ae2a643-68c3-4dd2-91ef-5048a0c23abe.009.png
[ref4]: Aspose.Words.9ae2a643-68c3-4dd2-91ef-5048a0c23abe.010.png