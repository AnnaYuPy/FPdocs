<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2024-05-14T18:36:59.879577949"><title>Прототипы | Help Instance</title><script type="application/json" id="virtual-toc-data">[]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b259/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Прототипы | Help Instance"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Help Instance Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/прототипы.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Прототипы | Help Instance"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/прототипы.html#webpage",
    "url": "writerside-documentation/прототипы.html",
    "name": "Прототипы | Help Instance",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Help Instance Help"
}</script><!-- End Schema.org --></head><body data-id="Прототипы" data-main-title="Прототипы" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Faceplate-Tutorial.md|Faceplate (Tutorial)"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Help Instance  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Прототипы" id="Прототипы.md">Прототипы</h1><p id="-ejj75z_5148">Понятие прототипов в IoT-платформах, таких как Faceplate, схоже с концепцией классов в объектно-ориентированном программировании. Другими словами они представляют собой шаблоны или формы для создания конкретных экземпляров объектов или устройств, определяя их структуру, свойства, содержимое и поведение. Это означает, что прототип включает в себя определение полей, их типы данных, методы и функции для работы с этими полями, а также логику для обработки событий и состояний объекта. Прототип является основой для создания конкретных экземпляров объектов или устройств в системе. Каждый экземпляр прототипа наследует его свойства и методы, а также может иметь собственные уникальные значения для полей. Прототип позволяет стандартизировать создание и управление объектами в IoT-платформе, обеспечивая повторное использование кода и упрощая разработку и сопровождение системы. Он также определяет интерфейс для взаимодействия с объектами и устройствами, что упрощает интеграцию и расширение функциональности системы.</p><p id="-ejj75z_5149">Вот несколько концепций использования прототипов:</p><ol class="list _decimal" id="-ejj75z_5150" type="1"><li class="list__item" id="-ejj75z_5151"><p>Ключ к созданию: Прототипы подобны образцам или черновикам, которые облегчают создание новых объектов или устройств. Они предоставляют основу, на которой можно основываться при создании новых экземпляров, помогая избежать повторения кода и ускоряя процесс разработки.</p></li><li class="list__item" id="-ejj75z_5152"><p>Модель для копирования: Прототипы можно рассматривать как модели, которые можно копировать для создания новых объектов с аналогичными характеристиками. Подобно тому, как можно использовать форму для создания нескольких копий одного документа, прототипы позволяют создавать множество экземпляров объектов, сохраняя их общие свойства и функциональность.</p></li><li class="list__item" id="-ejj75z_5153"><p>Стандартизация и единообразие: Прототипы помогают стандартизировать создание и управление объектами в системе, обеспечивая единообразие в структуре и поведении. Подобно тому, как шаблоны помогают сохранить единообразие дизайна в различных документах, прототипы обеспечивают согласованность в представлении и функциональности объектов в системе.</p></li><li class="list__item" id="-ejj75z_5154"><p>Упрощение изменений и обновлений: Поскольку прототипы определяют общие характеристики объектов, изменения, внесенные в прототип, автоматически распространяются на все его экземпляры. Это облегчает внесение изменений и обновлений в систему, так же как изменения в шаблоне документа могут быть применены ко всем его копиям. Использование в IoT-платформах Вот несколько причин, по которым прототипы могут быть полезны в IoT-платформах:</p></li><li class="list__item" id="-ejj75z_5155"><p>Ускорение разработки: Создание прототипов позволяет быстро оценить функциональность системы и визуализировать её работу. Это помогает разработчикам быстрее перейти к созданию рабочих версий системы.</p></li><li class="list__item" id="-ejj75z_5156"><p>Гибкость и масштабируемость: Использование прототипов обеспечивает гибкость при добавлении новых функций или изменении существующих. Это позволяет быстро адаптировать систему к изменяющимся требованиям.</p></li><li class="list__item" id="-ejj75z_5157"><p>Уменьшение рисков: Прототипирование позволяет выявить потенциальные проблемы или недочеты в дизайне системы на ранних этапах разработки. Это позволяет снизить риски и улучшить качество конечного продукта.</p></li><li class="list__item" id="-ejj75z_5158"><p>Разделение ответственности: Использование прототипов может помочь разделить функциональность системы на более мелкие компоненты, каждый из которых может быть разработан и тестирован независимо. Это способствует более эффективному управлению проектом.</p></li><li class="list__item" id="-ejj75z_5159"><p>Повышение понимания: Создание прототипов помогает участникам проекта лучше понять требования и ожидания от системы. Визуализация работы системы на ранних этапах разработки может привести к более точному пониманию её функциональности. Можно сделать вывод, что прототипы в IoT-платформах помогают ускорить процесс разработки, снизить риски и улучшить качество конечного продукта, делая разработку более эффективной и управляемой.</p></li></ol><p id="-ejj75z_5160">Рассмотрим несколько практических примеров использования прототипов в IoT-платформах с определением поведения с помощью скриптов:</p><ol class="list _decimal" id="-ejj75z_5161" type="1"><li class="list__item" id="-ejj75z_5162"><p>Прототип объекта устройства: Предположим, что в SCADA-системе необходимо работать с различными типами устройств, такими как насосы, клапаны, датчики и т.д. Создание прототипа класса устройства позволит определить общие характеристики и функциональность для всех типов устройств. С использованием скриптов, например, на основе JavaScript или Erlang, можно создать экземпляры этих устройств и определить их поведение в зависимости от различных условий (например, управление насосом в зависимости от уровня жидкости).</p></li><li class="list__item" id="-ejj75z_5163"><p>Прототип объекта сети: В IoT-платформах часто необходимо взаимодействовать с различными сетевыми устройствами, такими как контроллеры, коммутаторы и т.д. Создание прототипа класса сетевого устройства позволяет определить общие методы и свойства для работы с такими устройствами. С помощью скриптов можно автоматизировать задачи связи с этими устройствами, например, сбор данных о состоянии и управление ими.</p></li><li class="list__item" id="-ejj75z_5164"><p>Прототип объекта события: В IoT-платформах события играют важную роль, например, предупреждения о проблемах в работе оборудования или изменениях в процессах. Создание прототипа класса события позволяет определить общие характеристики и методы обработки событий. С помощью скриптов можно определить поведение системы при возникновении определенных событий, например, отправку уведомлений администратору или запуск аварийных процедур.</p></li><li class="list__item" id="-ejj75z_5165"><p>Прототип объекта данных: В IoT-платформах данные играют ключевую роль, так как они представляют информацию о состоянии оборудования, процессов и событий. Создание прототипа класса данных позволяет определить общие методы и свойства для работы с данными. С использованием скриптов можно выполнять различные операции с данными, например, фильтрацию, агрегацию или анализ. Создание прототипа Прототип можно создать на вкладке прототипы Proto1.png Кнопка Описание Proto1.1.png Кнопка обновления списка прототипов для получения актуальной информации, в том случае, когда с одним проектом работает несколько клиентов. Proto1.2.png Кнопка создания прототипа. При создании прототипа появляется окно: Proto2.png Proto1.3.png Кнопка редактирования прототипа Proto1.4.png Кнопка удаления прототипа Proto1.5.png Кнопка копирования прототипа Proto1.6.png Кнопка вставки прототипа Proto1.7.png Кнопка редактора прототипа Proto1.8.png Кнопка экспорта в базу в формате .xlsx файла Proto1.9.png Импорт из базы в формате .xlsx файла Proto1.10.png Кнопка экспорта проекта в файл Proto1.11.png Кнопка импорта проекта из файла</p></li></ol><p id="-ejj75z_5166">При создании прототипа появляется окно: Proto2.png Указание группы при создании прототипа в IoT-платформе или SCADA-системе может иметь несколько значений и целей, в зависимости от контекста и специфики системы. Вот несколько возможных интерпретаций значения указания группы:</p><ol class="list _decimal" id="-ejj75z_5167" type="1"><li class="list__item" id="-ejj75z_5168"><p>Организация и классификация: Группа может служить для организации и классификации прототипов по их функциональному или логическому назначению. Например, прототипы устройств могут быть сгруппированы по типу (например, датчики, актуаторы, контроллеры), а прототипы событий - по категориям (например, предупреждения, аварии, информационные сообщения).</p></li><li class="list__item" id="-ejj75z_5169"><p>Управление доступом и правами: Группировка прототипов может использоваться для управления доступом и правами пользователей. Например, администраторы могут иметь доступ к прототипам всех групп, в то время как обычные пользователи могут иметь доступ только к определенным группам, связанным с их функциональными обязанностями.</p></li><li class="list__item" id="-ejj75z_5170"><p>Контроль версий и жизненного цикла: Группы могут также использоваться для контроля версий и управления жизненным циклом прототипов. Например, прототипы одной группы могут быть связаны с конкретной версией проекта или продукта, а другие - с тестовыми или экспериментальными версиями.</p></li><li class="list__item" id="-ejj75z_5171"><p>Организация процесса разработки и управления проектами: Группы могут помочь организовать процесс разработки и управления проектами, разделяя прототипы на логические блоки или модули, которые могут быть разработаны и тестированы независимо друг от друга. В целом, указание группы при создании прототипа позволяет более эффективно организовать и управлять различными аспектами системы, такими как классификация, доступ, версии и процесс разработки.</p></li></ol><p id="-ejj75z_5172">Behavior - это скрипт, который отрабатывается при изменении (создание, редактирование, удаление) Прототипа.</p><p id="-ejj75z_5173">Пример вывода:</p><p id="-ejj75z_5174">Образец скрипта:</p><div class="code-block" data-lang="bash">
%%-----------------------------------------------------------------
%% This script is executed at the server side. The programming language
%% is Erlang.
%% The module MUST export next 3 methods:
%% * on_create/1 - this method is called when a new instance of the prototype is created.
%% * on_edit/1 - this method is called when own fields of an instance of the prototype are edited
%% * on_delete/1 - this method is called when an instance of the prototype is deleted
%% All this methods accept an Object of the instance and can edit or perform any other allowed code.
%% If any of the methods throw or crash the whole transaction will rollback.
%% If there are any warnings or not critical errors it is recommended to log them with available macros, examples:
%% ?LOGWARNING( &quot;my warning text: ~p&quot;, [Warning] )
%% ?LOGERROR( &quot;my error text: ~p&quot;, [Error] )
%% If the methods performs well it should return atom 'ok'.
%% For more info please refer to the documentation
%%-----------------------------------------------------------------
-module(fp_prototype_MyProto1).

-include(&quot;fp_struct.hrl&quot;).

-export([
on_create/1,
on_delete/1,
on_edit/1
]).

on_create(_Object)-&gt;
ok.

on_edit(_Object)-&gt;
ok.

on_delete( Object )-&gt;
ok.
</div><p id="-ejj75z_5176">Рассмотрим примеры создания скриптов, определяющих поведение прототипа на языке Erlang. Пример 1:</p><div class="code-block" data-lang="bash">
%%----------------------------------------------------------------- 
%% This script is executed at the server side. The programming language 
%% is Erlang. 
%% The module MUST export next 3 methods: 
%% * on_create/1 - this method is called when a new instance of the prototype is created. 
%% * on_edit/1 - this method is called when own fields of an instance of the prototype are edited 
%% * on_delete/1 - this method is called when an instance of the prototype is deleted 
%% All these methods accept an Object of the instance and can edit or perform any other allowed code. 
%% If any of the methods throw or crash, the whole transaction will rollback. 
%% If there are any warnings or non-critical errors, it is recommended to log them with available macros, examples: 
%% ?LOGWARNING( &quot;my warning text: ~p&quot;, [Warning] ) 
%% ?LOGERROR( &quot;my error text: ~p&quot;, [Error] ) 
%% If the methods perform well, they should return the atom 'ok'. 
%% For more info, please refer to the documentation 
%%----------------------------------------------------------------- 
-module(fp_prototype_MyProto1). 

-include(&quot;fp_struct.hrl&quot;). 

-export([ 
   on_create/1, 
   on_delete/1, 
   on_edit/1 
   ]). 

on_create(Object) -&gt; 
   io:format(&quot;Instance of MyProto1 created: ~p~n&quot;, [Object]), 
   ok. 
   
on_edit(Object) -&gt; 
   io:format(&quot;Fields of MyProto1 instance edited: ~p~n&quot;, [Object]), 
   ok. 
   
on_delete(Object) -&gt; 
   io:format(&quot;Instance of MyProto1 deleted: ~p~n&quot;, [Object]), 
   ok.
</div><p id="-ejj75z_5178">Этот скрипт реализует три метода: on_create, on_edit и on_delete, которые вызываются при создании, изменении и удалении экземпляра прототипа соответственно. В данном примере эти методы просто выводят сообщение в консоль, указывая на то, что произошло с экземпляром. Вы можете дополнить их логикой, соответствующей вашим требованиям. Пример 2. Давайте расширим последний скрипт для работы с прототипом, представляющим конкретное устройство. Для примера давайте предположим, что у нас есть прототип устройства, представляющего насос, и мы хотим, чтобы наш скрипт выполнял определенные действия в зависимости от состояния этого насоса.</p><div class="code-block" data-lang="bash">
%%----------------------------------------------------------------- 
%% This script is executed at the server side. The programming language 
%% is Erlang. 
%% The module MUST export next 3 methods: 
%% * on_create/1 - this method is called when a new instance of the prototype is created. 
%% * on_edit/1 - this method is called when own fields of an instance of the prototype are edited 
%% * on_delete/1 - this method is called when an instance of the prototype is deleted 
%% All these methods accept an Object of the instance and can edit or perform any other allowed code. 
%% If any of the methods throw or crash, the whole transaction will rollback. 
%% If there are any warnings or non-critical errors, it is recommended to log them with available macros, examples: 
%% ?LOGWARNING( &quot;my warning text: ~p&quot;, [Warning] ) 
%% ?LOGERROR( &quot;my error text: ~p&quot;, [Error] ) 
%% If the methods perform well, they should return the atom 'ok'. 
%% For more info, please refer to the documentation 
%%----------------------------------------------------------------- 
-module(fp_prototype_Pump). 

-include(&quot;fp_struct.hrl&quot;). 

-export([ 
   on_create/1, 
   on_delete/1, 
   on_edit/1 
]). 

-define(PUMP_STATE_NORMAL, 0). 
-define(PUMP_STATE_WARNING, 1). 
-define(PUMP_STATE_ERROR, 2). 

on_create(Object) -&gt; 
   io:format(&quot;Pump instance created: ~p~n&quot;, [Object]), 
   ok. 
on_edit(Object) -&gt; 
   % Проверяем состояние насоса и выполняем соответствующие действия 
   case Object#pump.state of 
      ?PUMP_STATE_NORMAL -&gt; 
         io:format(&quot;Pump is in normal state: ~p~n&quot;, [Object]), 
         ok; 
      ?PUMP_STATE_WARNING -&gt; 
         io:format(&quot;Pump is in warning state: ~p~n&quot;, [Object]), 
         ok; 
      ?PUMP_STATE_ERROR -&gt; 
         io:format(&quot;Pump is in error state: ~p~n&quot;, [Object]), 
         ok 
   end. 
   
on_delete(Object) -&gt; 
   io:format(&quot;Pump instance deleted: ~p~n&quot;, [Object]), 
   ok.
</div><p id="-ejj75z_5180">Этот скрипт добавляет обработку состояния насоса в методе on_edit. В зависимости от состояния насоса он выводит соответствующее сообщение в консоль. Вы можете дополнить скрипт логикой обработки состояний насоса, включая отправку уведомлений, запись в журнал или выполнение дополнительных действий. Пример 3. Прототипы в SCADA-системах часто имеют набор полей, которые определяют их свойства и характеристики. Для дать определение прототипа на основании этого, мы можем добавить определение полей в Erlang-модуль прототипа. Вот пример определения прототипа на основании всего выше перечисленного:</p><div class="code-block" data-lang="bash">
%%----------------------------------------------------------------- 
%% This script is executed at the server side. The programming language 
%% is Erlang. 
%% The module MUST export next 3 methods: 
%% * on_create/1 - this method is called when a new instance of the prototype is created. 
%% * on_edit/1 - this method is called when own fields of an instance of the prototype are edited 
%% * on_delete/1 - this method is called when an instance of the prototype is deleted 
%% All these methods accept an Object of the instance and can edit or perform any other allowed code. 
%% If any of the methods throw or crash, the whole transaction will rollback. 
%% If there are any warnings or non-critical errors, it is recommended to log them with available macros, examples: 
%% ?LOGWARNING( &quot;my warning text: ~p&quot;, [Warning] ) 
%% ?LOGERROR( &quot;my error text: ~p&quot;, [Error] ) 
%% If the methods perform well, they should return the atom 'ok'. 
%% For more info, please refer to the documentation 
%%----------------------------------------------------------------- 
-module(fp_prototype_Pump). 

-include(&quot;fp_struct.hrl&quot;). 

-export([ 
   on_create/1, 
   on_delete/1, 
   on_edit/1 
]). 

-record(pump, { 
   id :: string(), 
   name :: string(), 
   type :: string(), 
   state :: integer() 
}). 

-define(PUMP_STATE_NORMAL, 0). 
-define(PUMP_STATE_WARNING, 1). 
-define(PUMP_STATE_ERROR, 2). 

on_create(Object) -&gt; 
   io:format(&quot;Pump instance created: ~p~n&quot;, [Object]), 
   ok. 
   
on_edit(Object) -&gt; 
   % Проверяем состояние насоса и выполняем соответствующие действия 
   case Object#pump.state of 
      ?PUMP_STATE_NORMAL -&gt; 
         io:format(&quot;Pump is in normal state: ~p~n&quot;, [Object]), 
         ok; 
      ?PUMP_STATE_WARNING -&gt; 
         io:format(&quot;Pump is in warning state: ~p~n&quot;, [Object]), 
         ok; 
      ?PUMP_STATE_ERROR -&gt; 
         io:format(&quot;Pump is in error state: ~p~n&quot;, [Object]), 
         ok 
   end. 
   
on_delete(Object) -&gt; 
   io:format(&quot;Pump instance deleted: ~p~n&quot;, [Object]), 
   ok.
</div><p id="-ejj75z_5182">В этом примере добавлено определение полей прототипа pump, включая id, name, type и state. Для каждого поля указан тип данных. Теперь прототип насоса имеет определенную структуру данных, которая позволяет представлять его свойства и характеристики.</p><div class="last-modified">Last modified: 14 May 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="kpi.html" class="navigation-links__prev">KPI</a><a href="plc-соединения.html" class="navigation-links__next">PLC-соединения</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b259/app.js"></script></body></html>